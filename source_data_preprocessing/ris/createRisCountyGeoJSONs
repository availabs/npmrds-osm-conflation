#!/usr/bin/env node

const { exec } = require('child_process');
const { openSync, appendFileSync, closeSync } = require('fs');
const { join } = require('path');
const split = require('split2');
const { pipe, through } = require('mississippi');
const yargs = require('yargs');
const { sync: mkdirpSync } = require('mkdirp');
const _ = require('lodash');

const cliArgsSpec = {
  ris_gdb_zip: {
    demand: true,
    type: 'string',
    description:
      'Path to the RIS GeoDatabase. It is REQUIRED that every record has a populated County_Name field.'
  },
  output_dir: {
    demand: true,
    type: 'string',
    description:
      'The directory into which to write the county geojson files. Creates directory if it does not exist.'
  }
};

const { argv } = yargs
  .strict()
  .parserConfiguration({
    'camel-case-expansion': false,
    'flatten-duplicate-arrays': false
  })
  .wrap(yargs.terminalWidth() / 1.618)
  .option(cliArgsSpec)
  .usage(
    `Creates County partitions of the RIS geodatabase.
    One GeoJSON file is created per county.
    GeoJSON files are written into the specified --output_dir directory.
    SRS transformed to CRS84 (ESPG4326).

    USAGE:
      ogr2ogr -f GeoJSON /vsistdout/ -t_srs EPSG:4326 data/ris/RISDuplicate.gdb |
        jq -c '.features[]' |
        ./partitionRISGeodatabaseIntoCountyGeoJSONs --output_dir foo
    `
  );

const { ris_gdb_zip, output_dir } = argv;

mkdirpSync(output_dir);

const cmd = `
  ogr2ogr \
      -f GeoJSON \
      /vsistdout/ \
      /vsizip/${ris_gdb_zip} \
      -t_srs 'EPSG:4326' \
      -dim 2 \
      -preserve_fid |
    jq -c --stream 'fromstream(inputs | select( [.[0][0]] == ["features"]) | del(.[0][0:2])) | select(.)'`;

const { stdout: risFeatureStream } = exec(cmd, {
  //  Better to crash hard on out of memory than to get cryptic "pipe closed prematurely" error.
  maxBuffer: Infinity
});

const countyPartitionFDs = {};

const geoJSONHeader =
  '{"type":"FeatureCollection","name":"roadwayinventory","crs":{"type":"name","properties":{"name":"urn:ogc:def:crs:OGC:1.3:CRS84"}},"features":[';

pipe(
  risFeatureStream,
  split(JSON.parse),
  through.obj(
    function countyPartitioner(raw_feature, $, cb) {
      const feature = Object.assign({}, raw_feature, {
        properties: _.mapKeys(raw_feature.properties, (v, k) => k.toLowerCase())
      });

      const {
        properties: { county_name, gis_id, beg_mp }
      } = feature;

      if (!county_name) {
        throw new Error(
          'ERROR: Empty Column_Name field for RIS Geodatabase entry.'
        );
      }

      // eslint-disable-next-line no-param-reassign
      feature.properties.ogc_fid = `${gis_id}:${beg_mp}`;

      const d = JSON.stringify(feature);

      const normalizedCountyName = county_name
        .toLowerCase()
        .replace(/\./g, '')
        .replace(/ /g, '_');

      let fd = countyPartitionFDs[normalizedCountyName];

      if (!Number.isFinite(fd)) {
        const outf = join(output_dir, `ris.${normalizedCountyName}.geojson`);
        fd = openSync(outf, 'w');

        countyPartitionFDs[normalizedCountyName] = fd;

        appendFileSync(fd, `${geoJSONHeader}${d}`, 'utf8');
      } else {
        appendFileSync(fd, `,${d}`, 'utf8');
      }

      return cb();
    },
    function finish(cb) {
      Object.keys(countyPartitionFDs).forEach(county => {
        const fd = countyPartitionFDs[county];

        appendFileSync(fd, ']}');

        closeSync(fd);
      });

      return cb();
    }
  ),
  err => {
    if (err) {
      console.error(err);
    }
  }
);
