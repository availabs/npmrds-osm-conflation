#!/usr/bin/env node

const { openSync, appendFileSync, closeSync } = require('fs');
const { exec, execSync } = require('child_process');
const { isAbsolute, join, dirname, basename } = require('path');
const yargs = require('yargs');
const { pipe, through } = require('mississippi');
const split = require('split2');
const _ = require('lodash');
const csv = require('fast-csv');
const { sync: mkdirpSync } = require('mkdirp');

const cliArgsSpec = {
  tmc_identification: {
    demand: true,
    type: 'string'
  },
  npmrds_shapefile_zip: {
    demand: true,
    type: 'string'
  },
  output_dir: {
    demand: true,
    type: 'string',
    description:
      'The directory into which to write the county geojson files. Creates directory if it does not exist.'
  }
};

const geoJSONOpen =
  '{"type":"FeatureCollection","name":"npmrds_shapefile","crs":{"type":"name","properties":{"name":"urn:ogc:def:crs:OGC:1.3:CRS84"}},"features":[';

const geoJSONClose = ']}';

// .description(
// 'Joins the NPMRDS tmc_identification and npmrds_shapefile_zip metadata and outputs GeoJSON files, partitioned by county, to the specified output_dir directory.'
// )

const { argv } = yargs
  .strict()
  .parserConfiguration({
    'camel-case-expansion': false,
    'flatten-duplicate-arrays': false
  })
  .wrap(yargs.terminalWidth() / 1.618)
  .option(cliArgsSpec);

const { tmc_identification, npmrds_shapefile_zip, output_dir } = argv;

mkdirpSync(output_dir);

const getTmcMetadata = () => {
  const tmcMetadata = {};
  return new Promise((resolve, reject) =>
    pipe(
      csv.parseFile(tmc_identification, { headers: true, trim: true }),
      through.obj(async function loader(d, $, cb) {
        const { tmc } = d;

        tmcMetadata[tmc] = d;

        return cb();
      }),
      err => {
        if (err) {
          return reject(err);
        }

        return resolve(tmcMetadata);
      }
    )
  );
};

const createCountyGeoJSONs = tmcMetadata => {
  const shpFileDir = dirname(npmrds_shapefile_zip);
  const shpFileName = basename(npmrds_shapefile_zip);
  const cwd = isAbsolute(shpFileDir)
    ? shpFileDir
    : join(process.cwd(), shpFileDir);

  // If the shapefile zip has a subdirectory, we need to get it.
  let subDir;

  try {
    const zipContents = execSync(`zipinfo -1 ${npmrds_shapefile_zip} "*/"`, {
      encoding: 'utf8',
      stdio: ['pipe', 'pipe', null]
    });

    subDir = `/${_(zipContents.split())
      .map(s => _.trim(s))
      .uniq()
      .sortBy(s => -s.length)
      .first()}`;
  } catch (err) {
    subDir = '';
  }

  const countyPartitionFDs = {};

  return new Promise((resolve, reject) => {
    const { stdout: featuresStream, stderr } = exec(
      ` ogr2ogr \
          -f GeoJSON \
          -t_srs EPSG:4326 \
          /vsistdout/ \
          /vsizip/${shpFileName}${subDir} |
        jq --compact-output '.features[]'
      `,
      { cwd, maxBuffer: Infinity }
    );

    stderr.pipe(process.stderr);

    return pipe(
      featuresStream,
      split(JSON.parse),
      through.obj(
        function countyPartitioner(feature, $, cb) {
          // WARNING: DATA MUTATION. Standardize GeoJSON feature property keys.
          // eslint-disable-next-line no-param-reassign
          feature.properties = _.mapKeys(feature.properties, (v, k) =>
            _.lowerCase(k)
          );

          const {
            properties: { county, tmc }
          } = feature;

          if (!county) {
            throw new Error('ERROR: Empty county field for TMC entry.');
          }

          // eslint-disable-next-line no-param-reassign
          feature.id = tmc;

          const metadata = tmcMetadata[tmc];
          Object.assign(feature.properties, metadata);

          const line = JSON.stringify(feature);

          const normalizedCountyName = county
            .toLowerCase()
            .replace(/\./g, '')
            .replace(/ /g, '_');

          let fd = countyPartitionFDs[normalizedCountyName];

          if (fd === undefined) {
            const outf = join(
              output_dir,
              `npmrds.${normalizedCountyName}.geojson`
            );
            fd = openSync(outf, 'w');

            countyPartitionFDs[normalizedCountyName] = fd;

            appendFileSync(fd, `${geoJSONOpen}${line}`, 'utf8');
          } else {
            appendFileSync(fd, `,${line}`, 'utf8');
          }

          return cb();
        },
        function finish(cb) {
          Object.keys(countyPartitionFDs).forEach(county => {
            const fd = countyPartitionFDs[county];

            appendFileSync(fd, geoJSONClose);

            closeSync(fd);
          });

          return cb();
        }
      ),
      err => {
        if (err) {
          return reject(err);
        }

        return resolve();
      }
    );
  });
};

(async () => {
  const tmcMetadata = await getTmcMetadata();
  await createCountyGeoJSONs(tmcMetadata);
})();
