#!/usr/bin/env node

/* eslint no-continue: 0, no-await-in-loop: 0, no-param-reassign: 0, */

const { join } = require('path');
const { pipe, through } = require('mississippi');
const { sync: rimrafSync } = require('rimraf');
const { sync: mkdirpSync } = require('mkdirp');

const levelup = require('levelup');
const leveldown = require('leveldown');
const encode = require('encoding-down');

const _ = require('lodash');

const dbsParentDir = join(__dirname, '../../data/leveldb/');

const OSM_WAYS_DIR = join(dbsParentDir, 'osmWays');
const OSM_RESTRICTIONS_DIR = join(dbsParentDir, 'osmRestrictions');

const CONFLATION_MAP_DB = join(dbsParentDir, 'conflationMap/');
const CONFLATION_PAIRINGS_DB = join(dbsParentDir, 'conflationPairingsDB');

const CONFLATION_FEATURES_DIR = join(dbsParentDir, 'conflationFeatures');
const CONFLATION_WAYS_DIR = join(dbsParentDir, 'conflationWays');
const CONFLATION_NODES_DIR = join(dbsParentDir, 'conflationNodes');
const CONFLATION_RESTRICTIONS_DIR = join(
  dbsParentDir,
  'conflationRestrictions'
);

const TMP_NODES_LOOKUP_BY_COORD_DIR = join(
  dbsParentDir,
  'tmp-NodesLookupByCoord'
);

const TMP_WAYS_LOOKUP_DIR = join(dbsParentDir, 'tmp-WaysLookupBy');

// TODO: Take yargs --clean flag on whether to clean.
rimrafSync(CONFLATION_NODES_DIR);
rimrafSync(CONFLATION_WAYS_DIR);
rimrafSync(CONFLATION_FEATURES_DIR);
rimrafSync(CONFLATION_RESTRICTIONS_DIR);
rimrafSync(TMP_NODES_LOOKUP_BY_COORD_DIR);
rimrafSync(TMP_WAYS_LOOKUP_DIR);

mkdirpSync(CONFLATION_NODES_DIR);
mkdirpSync(CONFLATION_WAYS_DIR);
mkdirpSync(CONFLATION_RESTRICTIONS_DIR);
mkdirpSync(TMP_NODES_LOOKUP_BY_COORD_DIR);
mkdirpSync(TMP_WAYS_LOOKUP_DIR);

const JSON_ENC = { valueEncoding: 'json' };

const osmWaysDB = levelup(encode(leveldown(OSM_WAYS_DIR), JSON_ENC));
const osmRestrictionsDB = levelup(
  encode(leveldown(OSM_RESTRICTIONS_DIR), JSON_ENC)
);

const conflationMapDB = levelup(encode(leveldown(CONFLATION_MAP_DB), JSON_ENC));

const conflationPairingsDB = levelup(
  encode(leveldown(CONFLATION_PAIRINGS_DB), JSON_ENC)
);

const conflationFeaturesDB = levelup(
  encode(leveldown(CONFLATION_FEATURES_DIR), JSON_ENC)
);
const conflationWaysDB = levelup(
  encode(leveldown(CONFLATION_WAYS_DIR), JSON_ENC)
);
const conflationNodesDB = levelup(
  encode(leveldown(CONFLATION_NODES_DIR), JSON_ENC)
);
const conflationRestrictionsDB = levelup(
  encode(leveldown(CONFLATION_RESTRICTIONS_DIR), JSON_ENC)
);

const tmpNodesLookupByCoordDB = levelup(
  encode(leveldown(TMP_NODES_LOOKUP_BY_COORD_DIR), JSON_ENC)
);
const tmpWaysLookupDB = levelup(
  encode(leveldown(TMP_WAYS_LOOKUP_DIR), JSON_ENC)
);

let nodeIdSeq = 0;

const loadOSMNodes = () =>
  new Promise((resolve, reject) =>
    pipe(
      conflationMapDB.createValueStream(),
      through.obj(async function unpairedNodesLoader(feature, $, cb) {
        const {
          properties: { osmMetadata: { waySections } = {} } = {},
          geometry: { coordinates = null } = {}
        } = feature || {};

        const nodeIds = _(waySections)
          .map('nodeIds')
          .flatten()
          .value()
          .reduce((acc, nodeId) => {
            if (nodeId !== _.last(acc)) {
              acc.push(nodeId);
            }
            return acc;
          }, []);

        nodeIdSeq = Math.max(nodeIdSeq, ...nodeIds);

        if (nodeIds.length !== coordinates.length) {
          throw new Error(
            'ERROR: INVARIANT BROKEN. Number of nodeIds !== number of geometry vertices.'
          );
        }

        const nodeCoords = nodeIds.reduce((acc, nodeId, i) => {
          const [lon, lat] = coordinates[i];

          acc[nodeId] = {
            id: nodeId,
            lon: _.round(lon, 7),
            lat: _.round(lat, 7)
          };

          return acc;
        }, {});

        const dbPut = Object.keys(nodeCoords).map(id => ({
          type: 'put',
          key: id,
          value: nodeCoords[id]
        }));

        // NOTE: Can overwrite existing lookup node
        const lookUpPut = Object.keys(nodeCoords).map(id => ({
          type: 'put',
          key: `${nodeCoords[id].lon}|${nodeCoords[id].lat}`,
          value: id
        }));

        try {
          await Promise.all([
            conflationNodesDB.batch(dbPut),
            tmpNodesLookupByCoordDB.batch(lookUpPut)
          ]);
        } catch (err) {
          console.error('ERROR in batch put');
          throw err;
        }

        return cb();
      }),
      err => {
        if (err) {
          return reject(err);
        }
        return resolve();
      }
    )
  );

const loadWays = () => {
  let maxWayId = 0;

  return new Promise((resolve, reject) =>
    pipe(
      conflationPairingsDB.createValueStream(),
      through.obj(async function pairedNodesLoader(feature, $, cb) {
        const {
          properties: {
            state,
            OSM = null,
            NPMRDS = null,
            RIS = null,
            osmMetadata: { waySection: { nodeIds = null } = {} } = {}
          } = {},
          geometry: { coordinates = null } = {}
        } = feature || {};

        if (!state) {
          return cb();
        }

        if (!Array.isArray(nodeIds)) {
          throw new Error(
            'ERROR: INVARIANT BROKEN. No OSM nodeIds for split ShSt Reference'
          );
        }

        if (!Array.isArray(coordinates)) {
          throw new Error(
            'ERROR: INVARIANT BROKEN. No coordinates for split ShSt Reference'
          );
        }

        if (nodeIds.length !== coordinates.length) {
          throw new Error(
            'ERROR: INVARIANT BROKEN. Number of OSM nodeIds !== number of vertices in geometry.'
          );
        }

        if (nodeIds.slice(1, -1).some(nodeId => nodeId === null)) {
          console.error(JSON.stringify(nodeIds, null, 4));
          throw new Error(
            'ERROR: INVARIANT BROKEN. Internal nodes/vertices can not be synthetic (created during splitting).'
          );
        }

        // If node/vertex was added to shstRefernceGeometry for splitting
        if (_.first(nodeIds) === null) {
          const [lon, lat] = _.first(coordinates);
          try {
            nodeIds[0] = await tmpNodesLookupByCoordDB.get(`${lon}|${lat}`);
          } catch (err) {
            const id = ++nodeIdSeq;
            await conflationNodesDB.put(id, { id, lon, lat });
            await tmpNodesLookupByCoordDB.put(`${lon}|${lat}`, id);
            nodeIds[0] = id;
          }
        }

        // If node/vertex was added to shstRefernceGeometry for splitting
        if (_.last(nodeIds) === null) {
          const [lon, lat] = _.last(coordinates);
          try {
            nodeIds[nodeIds.length - 1] = await tmpNodesLookupByCoordDB.get(
              `${lon}|${lat}`
            );
          } catch (err) {
            const id = ++nodeIdSeq;
            await conflationNodesDB.put(id, { id, lon, lat });
            await tmpNodesLookupByCoordDB.put(`${lon}|${lat}`, id);
            nodeIds[nodeIds.length - 1] = id;
          }
        }

        let osmWay = null;

        try {
          osmWay = await osmWaysDB.get(OSM);
        } catch (err) {
          console.warn('WARNING: No osmWay data found for', OSM);
        }

        const id = ++maxWayId;

        const conflationWay = {
          id,
          nodes: nodeIds,
          tags: Object.assign(
            {},
            { OSM, NPMRDS, RIS },
            osmWay && _.omit(osmWay.tags, ['oneway']),
            _.mapKeys(
              _.omit(feature.properties, [
                'osmMetadata',
                'fsystem',
                'OSM',
                'RIS',
                'NPMRDS',
                'oneway',
                'oneWay'
              ]),
              (v, k) => `sharedstreets:${k}`
            ),
            { oneway: 'yes', oneWay: 'yes' }
          )
        };

        const conflationFeature = _.cloneDeep(feature);

        conflationFeature.properties = {
          id,
          osm: feature.properties.OSM,
          npmrds: _.get(feature.properties, 'NPMRDS', null),
          ris: _.get(feature.properties, 'RIS', null),
          shst: feature.properties.referenceId,
          totalSegments: feature.properties.totalSegments,
          segmentIndex: feature.properties.segmentIndex,
          networklevel: feature.properties.osmMetadata.fsystem
        };

        if (feature.properties.osmMetadata.oneWay) {
          conflationFeature.properties.networklevel += 0.5;
        }

        await Promise.all([
          conflationWaysDB.put(id, conflationWay),
          conflationFeaturesDB.put(id, conflationFeature),
          tmpWaysLookupDB.put(`${OSM}|startNode:${_.first(nodeIds)}`, id),
          tmpWaysLookupDB.put(`${OSM}|endNode:${_.last(nodeIds)}`, id)
        ]);

        return cb();
      }),
      err => {
        if (err) {
          return reject(err);
        }
        return resolve();
      }
    )
  );
};

const loadRestrictions = () => {
  let restrictionIdSeq = 0;
  return new Promise((resolve, reject) =>
    pipe(
      osmRestrictionsDB.createReadStream(),
      through.obj(async function pairedNodesLoader(
        { key: osmNodeId, value: restrictions },
        $,
        cb
      ) {
        if (osmNodeId === -1) {
          return cb();
        }

        if (!Array.isArray(restrictions)) {
          return cb();
        }

        for (let i = 0; i < restrictions.length; ++i) {
          const {
            members: { from = null, via = null, to = null },
            restriction
          } = restrictions[i];

          if (from === null || via === null || to === null) {
            continue;
          }
          try {
            const fromId = await tmpWaysLookupDB.get(`${from}|endNode:${via}`);
            const toId = await tmpWaysLookupDB.get(`${to}|startNode:${via}`);

            await conflationRestrictionsDB.put(++restrictionIdSeq, {
              from: fromId,
              via: +osmNodeId,
              to: toId,
              restriction
            });
          } catch (err) {
            // no entry
          }
        }
        return cb();
      }),
      err => {
        if (err) {
          return reject(err);
        }
        return resolve();
      }
    )
  );
};

(async () => {
  try {
    await loadOSMNodes();
    await loadWays();
    await loadRestrictions();
  } catch (err) {
    if (err && err.code !== 'EPIPE') {
      console.error('ERROR encountered while loading generated OSM DBs.');
      console.error(err);

      rimrafSync(CONFLATION_NODES_DIR);
      rimrafSync(CONFLATION_WAYS_DIR);
      rimrafSync(CONFLATION_FEATURES_DIR);
      rimrafSync(CONFLATION_RESTRICTIONS_DIR);

      process.exit(1);
    }
  } finally {
    rimrafSync(TMP_NODES_LOOKUP_BY_COORD_DIR);
    rimrafSync(TMP_WAYS_LOOKUP_DIR);
  }
})();
