#!/usr/bin/env node

const { readFileSync, readdirSync, writeFileSync } = require('fs');
const { join } = require('path');
const { pipe, through } = require('mississippi');
const turf = require('@turf/turf');
const _ = require('lodash');
const { sync: mkdirpSync } = require('mkdirp')

const levelup = require('levelup');
const leveldown = require('leveldown');
const encode = require('encoding-down');

const shapefilesDir = join(__dirname, '../../data/ris/county_geojson')
const qaDir = join(__dirname, '../../qa')

mkdirpSync(qaDir)


const CONFLATION_PAIRINGS_DB = join(
  __dirname,
  '../../data/leveldb/',
  'conflationPairingsDB'
);

const conflationPairingsDB = levelup(
  encode(leveldown(CONFLATION_PAIRINGS_DB), {
    valueEncoding: 'json'
  })
);

const getConflationStats = () => {
  const conflationStats = {};
  return new Promise((resolve, reject) =>
    pipe(
      conflationPairingsDB.createValueStream(),
      through.obj(function writer(feature, $, cb) {
        const ids = feature.properties.RIS;
        if (ids) {
          for (let i = 0; i < ids.length; ++i) {
            const id = ids[i];
            conflationStats[id] = conflationStats[id] || {};

            conflationStats[id].length = conflationStats[id].length || 0;
            conflationStats[id].length += turf.length(feature);

            conflationStats[id].manyRisSegs =
              conflationStats[id].manyRisSegs || ids.length > 1;
          }
        }

        return cb();
      }),
      err => {
        if (err) {
          return reject(err);
        }
        return resolve(conflationStats);
      }
    )
  );
};

(async () => {
  try {
    const conflationStats = await getConflationStats();

    const shapefiles = readdirSync(shapefilesDir)

    for (let i = 0; i < shapefiles.length; ++i) {
      const shapefileName = shapefiles[i]

      const risShapeFile = JSON.parse(
        readFileSync(
          join(__dirname, '../../data/ris/county_geojson/', shapefileName)
        )
      );

      for (let j = 0; j < risShapeFile.features.length; ++j) {
        const feature = risShapeFile.features[j];
        const { properties } = feature;
        const { ogc_fid } = properties;

        properties.isPaired = conflationStats[ogc_fid] !== undefined;

        properties.targetLength = turf.length(feature);

        properties.sourceLength = _.get(
          conflationStats,
          [ogc_fid, 'length'],
          null
        );

        properties.manyRisSegs = _.get(
          conflationStats,
          [ogc_fid, 'manyRisSegs'],
          null
        );

        properties.len_diff_ratio =
          properties.sourceLength &&
          Math.abs(properties.targetLength - properties.sourceLength) /
            properties.targetLength;

        properties.twoway_len_diff_ratio =
          properties.sourceLength &&
          Math.abs(properties.targetLength - properties.sourceLength / 2) /
            properties.targetLength;
      }

      writeFileSync(
        join(qaDir, shapefileName.replace(/geojson$/, 'qa.geojson')),
        JSON.stringify(risShapeFile)
      );
    }
  } catch (err) {
    if (err) {
      console.error('ERROR');
      console.error(err);
    }
  }
})();
