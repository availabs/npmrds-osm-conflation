#!/usr/bin/env node

/* eslint no-continue: 0 */

const { readFileSync } = require('fs');
const { join } = require('path');
const { pipe, through } = require('mississippi');
const _ = require('lodash');
const { sync: rimrafSync } = require('rimraf');
const { length, nearestPointOnLine } = require('@turf/turf');
const { point } = require('@turf/helpers');

const levelup = require('levelup');
const leveldown = require('leveldown');
const encode = require('encoding-down');

const KILOMETERS = {
  units: 'kilometers'
};

const SHST_GEOGRAPHY_DB = join(
  __dirname,
  '../../data/sharedstreets/shst_tiles_leveldb/shstGeographyDB'
);

const SHST_MATCHED_NPMRDS_DB = join(
  __dirname,
  '../../data/npmrds/shst_matched_leveldb/shstMatchedTMCs'
);

const TARGET_MAPS_SEGEMENT_OFFSETS_DB = join(
  __dirname,
  'targetMapsSegmentOffsets'
);

const shstGeographyDB = levelup(
  encode(leveldown(SHST_GEOGRAPHY_DB), { valueEncoding: 'json' })
);

const shstMatchedTMCsDB = levelup(
  encode(leveldown(SHST_MATCHED_NPMRDS_DB), { valueEncoding: 'json' })
);

const targetMapsSegmentsOffsetsDB = levelup(
  encode(leveldown(TARGET_MAPS_SEGEMENT_OFFSETS_DB), { valueEncoding: 'json' })
);

const tmcIsPrimary = JSON.parse(
  readFileSync(join(__dirname, './tmc_isprimary.json'))
);

pipe(
  shstMatchedTMCsDB.createValueStream(),
  through.obj(async function loader(matches, $, cb) {
    const geometryIds = _(matches)
      .map('properties.shstGeometryId')
      .uniq()
      .filter()
      .value();

    const shstGeometries = (await Promise.all(
      geometryIds.map(async id => {
        try {
          return await shstGeographyDB.get(id);
        } catch (err) {
          if (err.type === 'NotFoundError') {
            console.error(
              `WARNING: no geometry found in shstGeographyDB for ${id}`
            );
            return null;
          }
          console.error('shstGeographyDB.get');
          throw new Error(err);
        }
      })
    )).reduce((acc, geom) => {
      if (geom) {
        acc[geom.properties.id] = geom;
      }
      return acc;
    }, {});

    const targetMapsSegmentOffsetsLists = (await Promise.all(
      geometryIds.map(async id => {
        let list;

        try {
          list = await targetMapsSegmentsOffsetsDB.get(id);
        } catch (err) {
          if (err.type === 'NotFoundError') {
            list = [];
          } else {
            console.error('targetMapsSegmentsOffsetsDB.get');
            throw new Error(err);
          }
        }

        return { id, list };
      })
    )).reduce((acc, { id, list }) => {
      acc[id] = list;
      return acc;
    }, {});

    for (let i = 0; i < matches.length; ++i) {
      const {
        properties: { shstGeometryId, pp_tmc: tmc },
        geometry: { coordinates }
      } = matches[i];

      if (tmcIsPrimary[tmc] === 0) {
        continue;
      }

      const startPoint = point(_.first(coordinates));
      const endPoint = point(_.last(coordinates));

      const geom = shstGeometries[shstGeometryId];

      if (!geom) {
        continue;
      }

      // console.error(JSON.stringify({ startPoint, endPoint, geom }, null, 4));
      const offsetList = targetMapsSegmentOffsetsLists[shstGeometryId];

      const geomLength = length(geom, KILOMETERS);

      const snappedStart = nearestPointOnLine(geom, startPoint, KILOMETERS);
      const snappedEnd = nearestPointOnLine(geom, endPoint, KILOMETERS);

      // console.log(JSON.stringify({ snappedStart, snappedEnd }, null, 4));

      const startDist = snappedStart.properties.location;
      const endDist = snappedEnd.properties.location;

      const segmentOffsets = {
        shstGeometryId,
        geomLength,
        target_map: 'NPMRDS',
        target_map_id: tmc,
        POFF: Math.min(startDist, endDist),
        NOFF: geomLength - Math.max(startDist, endDist)
      };

      offsetList.push(segmentOffsets);
    }

    const batchPut = geometryIds.map(id => ({
      type: 'put',
      key: id,
      value: _.uniqWith(targetMapsSegmentOffsetsLists[id], _.isEqual)
    }));

    try {
      await targetMapsSegmentsOffsetsDB.batch(batchPut);
    } catch (err) {
      console.error('ERROR in batch put');
      throw err;
    }

    return cb();
  }),
  err => {
    if (err) {
      console.error(
        'ERROR encountered while loading targetMapsSegmentOffsets DB.'
      );
      console.error(
        `    Deleting the corruped database at ${TARGET_MAPS_SEGEMENT_OFFSETS_DB}`
      );
      console.error();
      console.error(err);
      rimrafSync(TARGET_MAPS_SEGEMENT_OFFSETS_DB);
      process.exit(1);
    }
  }
);
