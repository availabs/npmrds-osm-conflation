#!/usr/bin/env node

/* eslint no-continue: 0, prefer-destructuring: 0, no-labels: 0, no-restricted-syntax: 0 */
const { join } = require('path');
const { pipe, through } = require('mississippi');
const _ = require('lodash');
const { sync: rimrafSync } = require('rimraf');
const turf = require('@turf/turf');

const levelup = require('levelup');
const leveldown = require('leveldown');
const encode = require('encoding-down');

const PRECISION = 6;
const KILOMETERS = {
  units: 'kilometers'
};

const SPLIT_BUFF = 10 / 1000;
const LENGTH_RATIO_THRESHOLD = 0.5;

const CONFLATION_MAP_DB = join(
  __dirname,
  '../../data/leveldb/',
  'conflationMap/'
);

const CONFLATION_MAPS_SEGEMENT_OFFSETS_DB = join(
  __dirname,
  '../../data/leveldb/',
  'conflationMapsSegmentOffsets'
);

const CONFLATION_PAIRINGS_DB = join(
  __dirname,
  '../../data/leveldb/',
  'conflationPairingsDB'
);

rimrafSync(CONFLATION_PAIRINGS_DB);

const conflationMapDB = levelup(
  encode(leveldown(CONFLATION_MAP_DB), { valueEncoding: 'json' })
);

const conflationMapsSegmentsOffsetsDB = levelup(
  encode(leveldown(CONFLATION_MAPS_SEGEMENT_OFFSETS_DB), {
    valueEncoding: 'json'
  })
);

const conflationPairingsDB = levelup(
  encode(leveldown(CONFLATION_PAIRINGS_DB), {
    valueEncoding: 'json'
  })
);

pipe(
  conflationMapsSegmentsOffsetsDB.createReadStream(),
  through.obj(async function loader(
    { key: shstReferenceId, value: targetMapsSegmentOffsets },
    $,
    cb
  ) {
    // Build up the processed list by
    //   * snapping to terminal vertices and
    //   * removing pairings that do not meet a min shared dist threshold
    let shstRefGeom;

    try {
      shstRefGeom = await conflationMapDB.get(shstReferenceId);
    } catch (err) {
      if (err.type === 'NotFoundError') {
        console.error(
          `WARNING: no geometry found in shstGeographyDB for ${shstReferenceId}`
        );
        return cb();
      }
      throw new Error(err);
    }

    const shstRefGeomLength = turf.length(shstRefGeom, KILOMETERS);

    const shstRefGeomVertices = turf.explode(shstRefGeom);
    const shstRefGeomVerticesOffsets = shstRefGeomVertices.features.map(
      point => {
        const snappedPt = turf.nearestPointOnLine(
          shstRefGeom,
          point,
          KILOMETERS
        );

        const dist = snappedPt.properties.location;

        const poff = dist;
        const noff = shstRefGeomLength - dist;

        return [poff, noff];
      }
    );

    const POFF_IDX = 0;
    const NOFF_IDX = 1;

    const cleanedSegmentOffsetsByTargetMap = targetMapsSegmentOffsets.reduce(
      (acc, tmso) => {
        const { target_map, target_map_id, POFF, NOFF, fsystem } = tmso;

        // Snap the target segment terminal vertices to the source map terminal vertices
        //   if they are within SPLIT_BUFF distance of the source terminal vertices.
        let startDist;
        let endDist;

        if (POFF <= SPLIT_BUFF) {
          startDist = 0;
        } else {
          // See if we can reuse an original OSM/ShSt node rather than inserting a new one.
          let closestVert = null;
          let closestDist = Infinity;

          for (let i = 1; i < shstRefGeomVerticesOffsets.length; ++i) {
            const [v_poff] = shstRefGeomVerticesOffsets[i];
            const dist = Math.abs(POFF - v_poff);
            if (dist < closestDist) {
              // tie goes to first
              closestDist = dist;

              if (dist <= SPLIT_BUFF / 2) {
                closestVert = i;
              }
            }
          }

          startDist =
            closestVert !== null
              ? shstRefGeomVerticesOffsets[closestVert][POFF_IDX]
              : _.round(POFF, PRECISION);
        }

        if (NOFF <= SPLIT_BUFF) {
          endDist = shstRefGeomLength;
        } else {
          // See if we can reuse an original OSM/ShSt node rather than inserting a new one.
          let closestVert = null;
          let closestDist = Infinity;

          for (let i = 1; i < shstRefGeomVerticesOffsets.length; ++i) {
            const [, v_noff] = shstRefGeomVerticesOffsets[i];
            const dist = Math.abs(NOFF - v_noff);

            if (dist <= closestDist) {
              // tie goes to last
              closestDist = dist;

              if (dist <= SPLIT_BUFF / 2) {
                closestVert = i;
              }
            }
          }

          endDist =
            closestVert !== null
              ? shstRefGeomVerticesOffsets[closestVert][NOFF_IDX]
              : _.round(shstRefGeomLength - NOFF, PRECISION);
        }

        const segLen = endDist - startDist;

        if (
          segLen >= SPLIT_BUFF ||
          segLen / shstRefGeomLength >= LENGTH_RATIO_THRESHOLD
        ) {
          acc[target_map] = acc[target_map] || [];

          acc[target_map].push({
            target_map,
            target_map_id,
            fsystem,
            startDist,
            endDist
          });
        }

        return acc;
      },
      {}
    );

    // Remove overlapping target map segments
    // WARNING: Object mutations
    const nonOverlappingSegmentOffsets = Object.keys(
      cleanedSegmentOffsetsByTargetMap
    ).reduce((acc, target_map) => {
      const networkRankedToAddOffsets = _.sortBy(
        _.cloneDeep(cleanedSegmentOffsetsByTargetMap[target_map]),
        ['fsytem', 'target_map_id']
      );

      const nonOverlapping = [networkRankedToAddOffsets[0]];

      outerLoop: for (
        let toAddIdx = 1;
        toAddIdx < networkRankedToAddOffsets;
        ++toAddIdx
      ) {
        // Because networkRankedToAddOffsets is sorted by rank,
        //   toAdd will never mutate a member of nonOverlapping.
        //   However, nonOverlapping elements may mutate toAdd.
        const toAdd = networkRankedToAddOffsets[toAddIdx];

        // Since we are pushing to the end of the nonOverlapping list from within
        //   the following loop, we want to stop at the current last element.
        //   All elements after the current last were added as a result of
        //   the effects of toAdd on the currently existing nonOverlapping list members.
        const endAt = networkRankedToAddOffsets.length;

        for (
          let alreadyAddedIdx = 0;
          alreadyAddedIdx < endAt;
          ++alreadyAddedIdx
        ) {
          const aleadyAdded = nonOverlapping[alreadyAddedIdx];

          if (!aleadyAdded) {
            continue;
          }

          if (
            // toAdd      : o-----o
            // aleadyAdded:    o-----o
            toAdd.startDist <= aleadyAdded.startDist &&
            toAdd.endDist >= aleadyAdded.startDist
          ) {
            toAdd.endDist = aleadyAdded.startDist;

            if (toAdd.endDist - toAdd.startDist > SPLIT_BUFF) {
              nonOverlapping.push(toAdd);
            }
          } else if (
            // toAdd      :    o-----o
            // aleadyAdded: o-----o
            toAdd.startDist >= aleadyAdded.startDist &&
            toAdd.startDist <= aleadyAdded.endDist
          ) {
            toAdd.startDist = aleadyAdded.endDist;

            if (toAdd.endDist - toAdd.startDist > SPLIT_BUFF) {
              nonOverlapping.push(toAdd);
            }
          } else if (
            // toAdd      : o-------o
            // aleadyAdded:   o---o
            toAdd.startDist <= aleadyAdded.startDist &&
            toAdd.endDist >= aleadyAdded.endDist
          ) {
            // split toAdd, removing the section that overlaps alreadyAdded

            const omitBeginningSeg =
              aleadyAdded.startDist - toAdd.startDist <= SPLIT_BUFF;

            const omitEndingSeg =
              toAdd.endDist - aleadyAdded.endDist <= SPLIT_BUFF;

            if (omitBeginningSeg && omitEndingSeg) {
              // After removing the section from toAdd that overlaps the higher ranked segment,
              //   the remaining pieces of toAdd are too short to be included.
              continue outerLoop;
            } else if (omitBeginningSeg) {
              // toAdd begins where alreadyAdded ends
              toAdd.startDist = aleadyAdded.endDist;
            } else if (omitEndingSeg) {
              // toAdd ends where alreadyAdded begins
              toAdd.endDist = aleadyAdded.startDist;
            } else {
              // make a clone of toAdd
              const toAddClone = _.cloneDeep(toAdd);

              // The first segment of toAdd ends where the higher ranked segment begins
              //   We simply mutate toAdd. This trimmed segment continues along the inner loop.
              toAdd.endDist = aleadyAdded.startDist;

              // We need to insert the second segment of toAdd into networkRankedToAddOffsets.
              toAddClone.startDist = aleadyAdded.endDist;

              // Because the second segment of toAdd would have the same network rank
              //   we need to insert it into the networkRankedToAddOffsets list
              networkRankedToAddOffsets.splice(toAddIdx + 1, 0, toAddClone);
            }
          } else if (
            // toAdd      :   o---o
            // aleadyAdded: o-------o
            toAdd.startDist >= aleadyAdded.startDist &&
            toAdd.endDist <= aleadyAdded.endDist
          ) {
            // toAdd is completely covered by a higher ranked segment. Omit it.
            continue;
          } else {
            // does not overlap any higer ranked segments. Add it unmutated.
            nonOverlapping.push(toAdd);
          }
        }
      }

      // remove the nulled out segments
      acc[target_map] = nonOverlapping.filter(s => s);

      return acc;
    }, {});

    const processedOffsetsList = _.flatten(
      _.values(nonOverlappingSegmentOffsets)
    );

    if (!processedOffsetsList.length) {
      return cb();
    }

    const splitterOffsets = _(
      Array.prototype.concat(
        [0, shstRefGeomLength],
        processedOffsetsList.map(({ startDist, endDist }) => [
          startDist,
          endDist
        ])
      )
    )
      .flatten()
      .filter(v => v !== null)
      .sortBy(_.toNumber)
      .sortedUniq()
      .value();

    const segmentLineStrings = [];

    for (let i = 1; i < splitterOffsets.length; ++i) {
      const startDist = splitterOffsets[i - 1];
      const endDist = splitterOffsets[i];

      const segment = turf.lineSliceAlong(
        shstRefGeom,
        startDist,
        endDist,
        KILOMETERS
      );

      segment.properties = Object.assign({}, shstRefGeom.properties, {
        totalSegments: splitterOffsets.length - 1,
        segmentIndex: i,
        startDist,
        endDist
      });

      // For all but the fist segment (loop starts at i = 1)
      if (i > 1) {
        // Was this segment's startDistance included in the original geom vertices?
        const startVertIdx = shstRefGeomVerticesOffsets.findIndex(
          ([distAlong]) => startDist === distAlong
        );

        // If not, we need to record that we are inserting a new vertex for the startNode.
        //   Note: We only insert startNodes.
        //         The terminal nodes of the shstRefGeom never require creation/insertion.
        //         Additionaly, an internal segment's startNode is the preceding segment's endNode.
        if (startVertIdx === -1) {
          segment.properties.insertedStartNode = turf.along(
            shstRefGeom,
            startDist,
            KILOMETERS
          );
        }
      }

      segmentLineStrings.push(segment);
    }

    // Restore the original start and end coords
    _.first(segmentLineStrings).geometry.coordinates[0] =
      shstRefGeom.geometry.coordinates[0];

    _.last(segmentLineStrings).geometry.coordinates[
      _.last(segmentLineStrings).geometry.coordinates.length - 1
    ] = _.last(shstRefGeom.geometry.coordinates);

    for (let i = 0; i < processedOffsetsList.length; ++i) {
      const {
        startDist: tmsStartDist,
        endDist: tmsEndDist,
        target_map,
        target_map_id
      } = processedOffsetsList[i];

      for (let j = 0; j < segmentLineStrings.length; ++j) {
        const segment = segmentLineStrings[j];
        const {
          properties: { startDist, endDist }
        } = segment;

        // If targetMapSeg overlaps sourceMapSeg, assign the targetMapId
        //   to the segment's respective targetMap property.
        if (
          // targetMapSeg begins before or at sourceMapSeg beginning
          tmsStartDist <= startDist &&
          // targetMapSeg begins before sourceMapSeg ending
          tmsStartDist < endDist &&
          // targetMapSeg ends after sourceMapSeg begins
          tmsEndDist > startDist
        ) {
          if (segment.properties[target_map]) {
            throw new Error(
              'ERROR: Invariant broken. More than one target_map segment per source map segment.'
            );
          }
          segment.properties[target_map] = target_map_id;
        }
      }
    }

    const batchPut = segmentLineStrings.map(segment => ({
      type: 'put',
      key: `${shstReferenceId}${
        // If the source map segment was split, append the segmentIndex to the id.
        segment.properties.totalSegments > 1
          ? `.${segment.properties.segmentIndex}`
          : ''
      }`,
      value: segment
    }));

    try {
      await conflationPairingsDB.batch(batchPut);
    } catch (err) {
      console.error('ERROR in batch put');
      throw err;
    }

    return cb();
  }),
  err => {
    if (err && err.code !== 'EPIPE') {
      console.error(
        'ERROR encountered while loading targetMapsSegmentOffsets DB.'
      );
      console.error(
        `    Deleting the corruped database at ${CONFLATION_PAIRINGS_DB}`
      );
      console.error();
      console.error(err);
      rimrafSync(CONFLATION_PAIRINGS_DB);
      process.exit(1);
    }
  }
);
