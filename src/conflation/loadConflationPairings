#!/usr/bin/env node

/* eslint no-continue: 0, prefer-destructuring: 0 */
const { join } = require('path');
const { pipe, through } = require('mississippi');
const _ = require('lodash');
const { sync: rimrafSync } = require('rimraf');
const turf = require('@turf/turf');

const levelup = require('levelup');
const leveldown = require('leveldown');
const encode = require('encoding-down');

const PRECISION = 6;
const KILOMETERS = {
  units: 'kilometers'
};

const SPLIT_BUFF = 10 / 1000;

const CONFLATION_MAP_DB = join(
  __dirname,
  '../../data/leveldb/',
  'conflationMap/'
);

const CONFLATION_MAPS_SEGEMENT_OFFSETS_DB = join(
  __dirname,
  '../../data/leveldb/',
  'conflationMapsSegmentOffsets'
);

const CONFLATION_PAIRINGS_DB = join(
  __dirname,
  '../../data/leveldb/',
  'conflationPairingsDB'
);

rimrafSync(CONFLATION_PAIRINGS_DB);

const conflationMapDB = levelup(
  encode(leveldown(CONFLATION_MAP_DB), { valueEncoding: 'json' })
);

const conflationMapsSegmentsOffsetsDB = levelup(
  encode(leveldown(CONFLATION_MAPS_SEGEMENT_OFFSETS_DB), {
    valueEncoding: 'json'
  })
);

const conflationPairingsDB = levelup(
  encode(leveldown(CONFLATION_PAIRINGS_DB), {
    valueEncoding: 'json'
  })
);

pipe(
  conflationMapsSegmentsOffsetsDB.createReadStream(),
  through.obj(async function loader(
    { key: shstReferenceId, value: targetMapsSegmentOffsets },
    $,
    cb
  ) {
    // Build up the processed list by
    //   * snapping to terminal vertices and
    //   * removing pairings that do not meet a min shared dist threshold
    let referenceGeometry;

    try {
      referenceGeometry = await conflationMapDB.get(shstReferenceId);
    } catch (err) {
      if (err.type === 'NotFoundError') {
        console.error(
          `WARNING: no geometry found in shstGeographyDB for ${shstReferenceId}`
        );
        return cb();
      }
      throw new Error(err);
    }

    const shstGeometryLength = turf.length(referenceGeometry, KILOMETERS);

    const processedList = [];
    for (let i = 0; i < targetMapsSegmentOffsets.length; ++i) {
      // targetMapsSegmentOffsets fields:
      //   * shstReferenceId
      //   * geomLength
      //   * target_map
      //   * target_map_id
      //   * POFF
      //   * NOFF
      const tmso = targetMapsSegmentOffsets[i];

      const processedTMSO = _.pick(tmso, ['target_map', 'target_map_id']);

      processedTMSO.startDist =
        tmso.POFF > SPLIT_BUFF ? _.round(tmso.POFF, PRECISION) : 0;

      processedTMSO.endDist =
        tmso.NOFF > SPLIT_BUFF
          ? _.round(shstGeometryLength - tmso.NOFF, PRECISION)
          : shstGeometryLength;

      if (
        tmso.geomLength <= SPLIT_BUFF ||
        processedTMSO.endDist - processedTMSO.startDist >= SPLIT_BUFF
      ) {
        processedList.push(processedTMSO);
      }
    }

    if (!processedList.length) {
      return cb();
    }

    const splitterOffsets = _(
      processedList.map(({ startDist, endDist }) => {
        const offsets = [0];
        offsets.push(startDist);
        offsets.push(endDist);
        offsets.push(shstGeometryLength);
        return offsets;
      })
    )
      .flatten()
      .filter(v => v !== null)
      .sortBy(_.toNumber)
      .sortedUniq()
      .value();

    const segmentLineStrings = [];

    for (let i = 1; i < splitterOffsets.length; ++i) {
      const startDist = splitterOffsets[i - 1];
      const endDist = splitterOffsets[i];

      const segment = turf.lineSliceAlong(
        referenceGeometry,
        startDist,
        endDist,
        KILOMETERS
      );

      segment.properties = Object.assign({}, referenceGeometry.properties, {
        totalSegments: splitterOffsets.length - 1,
        segmentIndex: i,
        startDist,
        endDist
      });

      segmentLineStrings.push(segment);
    }

    // Restore the original start and end coords
    _.first(segmentLineStrings).geometry.coordinates[0] =
      referenceGeometry.geometry.coordinates[0];

    _.last(segmentLineStrings).geometry.coordinates[
      _.last(segmentLineStrings).geometry.coordinates.length - 1
    ] = _.last(referenceGeometry.geometry.coordinates);

    for (let i = 0; i < processedList.length; ++i) {
      const {
        startDist: tmsStartDist,
        endDist: tmsEndDist,
        target_map,
        target_map_id
      } = processedList[i];

      for (let j = 0; j < segmentLineStrings.length; ++j) {
        const segment = segmentLineStrings[j];
        const {
          properties: { startDist, endDist }
        } = segment;

        if (
          tmsStartDist <= startDist &&
          tmsStartDist < endDist &&
          tmsEndDist > startDist
        ) {
          segment.properties[target_map] = segment.properties[target_map] || [];
          segment.properties[target_map].push(target_map_id);
          segment.properties[target_map] = _.uniq(
            segment.properties[target_map]
          );

          // if (segment.properties[target_map]) {
          // console.error(
          // 'INVARIANT BROKEN: More than one target_map segment per source map segment.'
          // );
          // console.error(`  referenceGeometry:  ${shstReferenceId}`);
          // console.error(`  target_map:    ${target_map}`);
          // console.error(
          // `  target_map_ids: ${segment.properties[target_map]}, ${target_map_id}`
          // );
          // } else {
          // segment.properties[target_map] = target_map_id;
          // }
        }
      }
    }

    const batchPut = segmentLineStrings.map(segment => ({
      type: 'put',
      key: `${shstReferenceId}${
        segment.properties.totalSegments > 1
          ? `.${segment.properties.segmentIndex}`
          : ''
      }`,
      value: segment
    }));

    try {
      await conflationPairingsDB.batch(batchPut);
    } catch (err) {
      console.error('ERROR in batch put');
      throw err;
    }

    return cb();
  }),
  err => {
    if (err && err.code !== 'EPIPE') {
      console.error(
        'ERROR encountered while loading targetMapsSegmentOffsets DB.'
      );
      console.error(
        `    Deleting the corruped database at ${CONFLATION_PAIRINGS_DB}`
      );
      console.error();
      console.error(err);
      rimrafSync(CONFLATION_PAIRINGS_DB);
      process.exit(1);
    }
  }
);
