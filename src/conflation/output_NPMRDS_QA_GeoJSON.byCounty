#!/usr/bin/env node

const { readFileSync, readdirSync, writeFileSync } = require('fs');
const { join } = require('path');
const { pipe, through } = require('mississippi');
const turf = require('@turf/turf');
const _ = require('lodash');
const { sync: mkdirpSync } = require('mkdirp')

const levelup = require('levelup');
const leveldown = require('leveldown');
const encode = require('encoding-down');

const CONFLATION_PAIRINGS_DB = join(
  __dirname,
  '../../data/leveldb/',
  'conflationPairingsDB'
);

const conflationPairingsDB = levelup(
  encode(leveldown(CONFLATION_PAIRINGS_DB), {
    valueEncoding: 'json'
  })
);

const tmcIsPrimary = JSON.parse(
  readFileSync(join(__dirname, './tmc_isprimary.json'))
);

const shapefilesDir = join(__dirname, '../../data/npmrds/county_geojson')
const qaDir = join(__dirname, '../../qa')

mkdirpSync(qaDir)

const getConflationStats = () => {
  const conflationStats = {};
  return new Promise((resolve, reject) =>
    pipe(
      conflationPairingsDB.createValueStream(),
      through.obj(function writer(feature, $, cb) {
        const tmcs = feature.properties.NPMRDS;
        if (tmcs) {
          for (let i = 0; i < tmcs.length; ++i) {
            const tmc = tmcs[i];
            conflationStats[tmc] = conflationStats[tmc] || {};

            conflationStats[tmc].length = conflationStats[tmc].length || 0;
            conflationStats[tmc].length += turf.length(feature);

            conflationStats[tmc].oneOfMany =
              conflationStats[tmc].oneOfMany || tmcs.length > 1;
          }
        }

        return cb();
      }),
      err => {
        if (err) {
          return reject(err);
        }
        return resolve(conflationStats);
      }
    )
  );
};

(async () => {
  try {
    const conflationStats = await getConflationStats();

    const shapefiles = readdirSync(shapefilesDir)

    for (let i = 0; i < shapefiles.length; ++i) {
      const shapefileName = shapefiles[i]

      const tmcShapeFile = JSON.parse(
        readFileSync(
          join(__dirname, '../../data/npmrds/county_geojson/', shapefileName)
        )
      );

      for (let j = 0; j < tmcShapeFile.features.length; ++j) {
        const feature = tmcShapeFile.features[j];
        const { properties } = feature;
        const { Tmc } = properties;

        properties.isPrimary = tmcIsPrimary[Tmc] !== 0;
        properties.isPaired = conflationStats[Tmc] !== undefined;

        if (properties.isPrimary) {
          properties.targetLength = turf.length(feature);
          properties.sourceLength = _.get(conflationStats, [Tmc, 'length'], null);
          properties.oneOfMany = _.get(conflationStats, [Tmc, 'oneOfMany'], null);
        }

        properties.len_diff_ratio = properties.isPrimary
          ? Math.abs(properties.targetLength - properties.sourceLength) /
            properties.targetLength
          : null;
      }

      writeFileSync(
        join(qaDir, shapefileName.replace(/geojson$/, 'qa.geojson')),
        JSON.stringify(tmcShapeFile)
      );
    }

  } catch (err) {
    if (err) {
      console.error('ERROR');
      console.error(err);
    }
  }
})();
