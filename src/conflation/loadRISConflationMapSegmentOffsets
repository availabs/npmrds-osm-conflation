#!/usr/bin/env node

/* eslint no-continue: 0 */

const { join } = require('path');
const { pipe, through } = require('mississippi');
const _ = require('lodash');
const { sync: rimrafSync } = require('rimraf');
const { length, nearestPointOnLine } = require('@turf/turf');
const { point } = require('@turf/helpers');

const levelup = require('levelup');
const leveldown = require('leveldown');
const encode = require('encoding-down');

const KILOMETERS = {
  units: 'kilometers'
};

const SPLIT_BUFF_KM = 10 / 1000;

const CONFLATION_MAP_DB = join(__dirname, '../../data/leveldb/conflationMap/');

const SHST_MATCHED_RIS_DB = join(
  __dirname,
  '../../data/leveldb/',
  'shstMatchedRis'
);

const CONFLATION_MAPS_SEGEMENT_OFFSETS_DB = join(
  __dirname,
  '../../data/leveldb/',
  'conflationMapsSegmentOffsets'
);

const conflationMapDB = levelup(
  encode(leveldown(CONFLATION_MAP_DB), { valueEncoding: 'json' })
);

const shstMatchedRISSegmentsDB = levelup(
  encode(leveldown(SHST_MATCHED_RIS_DB), { valueEncoding: 'json' })
);

const conflationMapsSegmentsOffsetsDB = levelup(
  encode(leveldown(CONFLATION_MAPS_SEGEMENT_OFFSETS_DB), {
    valueEncoding: 'json'
  })
);

pipe(
  shstMatchedRISSegmentsDB.createValueStream(),
  through.obj(async function loader(matches, $, cb) {
    const shstReferenceIds = [
      ...matches.reduce((acc, { properties: { shstReferenceId } }) => {
        if (shstReferenceId) {
          acc.add(shstReferenceId);
        }
        return acc;
      }, new Set())
    ];

    const conflationMapFeatures = (await Promise.all(
      shstReferenceIds.map(async id => {
        try {
          const feature = await conflationMapDB.get(id);
          return { id, feature };
        } catch (err) {
          if (err.type === 'NotFoundError') {
            console.warn(
              `WARNING: no feature found in conflationMapDB for ${id}`
            );
            return null;
          }
          throw new Error(err);
        }
      })
    )).reduce((acc, d) => {
      if (d) {
        acc[d.id] = d.feature;
      }
      return acc;
    }, {});

    const conflationMapsSegmentOffsetsLists = (await Promise.all(
      shstReferenceIds.map(async id => {
        let list;

        try {
          list = await conflationMapsSegmentsOffsetsDB.get(id);
        } catch (err) {
          if (err.type === 'NotFoundError') {
            list = [];
          } else {
            console.error('conflationMapsSegmentsOffsetsDB.get');
            throw new Error(err);
          }
        }

        return { id, list };
      })
    )).reduce((acc, { id, list }) => {
      acc[id] = list;
      return acc;
    }, {});

    for (let i = 0; i < matches.length; ++i) {
      const {
        properties: {
          shstReferenceId,
          pp_ogc_fid: ogc_fid,
          pp_Functional_Class: fsystem
        },
        geometry: { coordinates }
      } = matches[i];

      const startPoint = point(_.first(coordinates));
      const endPoint = point(_.last(coordinates));

      const geom = conflationMapFeatures[shstReferenceId];

      if (!geom) {
        continue;
      }

      const geomLength = length(geom, KILOMETERS);

      const offsetList = conflationMapsSegmentOffsetsLists[shstReferenceId];

      const snappedStart = nearestPointOnLine(geom, startPoint, KILOMETERS);
      const snappedEnd = nearestPointOnLine(geom, endPoint, KILOMETERS);

      const startDist = snappedStart.properties.location;
      const endDist = snappedEnd.properties.location;

      if (Math.abs(startDist - endDist) < SPLIT_BUFF_KM) {
        continue;
      }

      const segmentOffsets = {
        shstReferenceId,
        geomLength,
        target_map: 'RIS',
        target_map_id: ogc_fid,
        fsystem,
        POFF: Math.min(startDist, endDist),
        NOFF: geomLength - Math.max(startDist, endDist),
        reversed: startDist > endDist
      };

      offsetList.push(segmentOffsets);
    }

    const batchPut = shstReferenceIds.map(id => ({
      type: 'put',
      key: id,
      value: _.uniqWith(conflationMapsSegmentOffsetsLists[id], _.isEqual)
    }));

    try {
      await conflationMapsSegmentsOffsetsDB.batch(batchPut);
    } catch (err) {
      console.error('ERROR in batch put');
      throw err;
    }

    return cb();
  }),
  err => {
    if (err) {
      console.error(
        'ERROR encountered while loading conflationMapsSegmentOffsets DB.'
      );
      console.error(
        `    Deleting the corruped database at ${CONFLATION_MAPS_SEGEMENT_OFFSETS_DB}`
      );
      console.error();
      console.error(err);
      rimrafSync(CONFLATION_MAPS_SEGEMENT_OFFSETS_DB);
      process.exit(1);
    }
  }
);
