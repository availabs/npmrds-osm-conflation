#!/usr/bin/env node

/* eslint no-restricted-syntax: 0, no-continue: 0 */

const _ = require('lodash');

const dao = require('../daos/shstReferencesMatchesDAO');
// const conflationMapService = require('../services/conflationMapLevelDbService');
const shstMatchesLevelDbService = require('../services/shstMatchesLevelDbService');

const getShstReferenceAuxProperties = require('./getShstReferenceAuxProperties');
const getShstMatchedSegmentOffsetsByTargetMap = require('./getShstMatchedSegmentOffsetsByTargetMap');
const partitionShstReferenceByTargetMapsMatches = require('./partitionShstReferenceByTargetMapsMatches');

const BATCH_SIZE = 1024;

(async () => {
  const iterator = dao.makeShStReferenceFeatureWithMatchesAsyncIterator();

  const batch = [];

  for await (const {
    shstReferenceFeature,
    shstMatchesByTargetMap
  } of iterator) {
    const { id } = shstReferenceFeature;

    // FIXME: We need to output this segment with just the OSM wayIds in this case.
    if (_.isNil(shstMatchesByTargetMap)) {
      console.log('NO MATCHES');
      continue;
    }

    const shstReferenceAuxProperties = getShstReferenceAuxProperties(
      shstReferenceFeature
    );

    // const curShstReferenceIdxForTargetMapSegments = await Promise.all(
    // Object.key(shstMatchesByTargetMap).map(targetMap =>
    // Promise.all(
    // Object.keys(shstMatchesByTargetMap[targetMap]).map(
    // ({ targetMapId }) =>
    // shstMatchesLevelDbService.getShstReferencesChainForTargetMapId(
    // targetMap,
    // targetMapId
    // )
    // )
    // )
    // )
    // );

    const d = Object.keys(shstMatchesByTargetMap.npmrds_2017).map(
      ({ targetMapId }) =>
        shstMatchesLevelDbService.getShstReferencesChainForTargetMapId(
          'npmrds_2017',
          targetMapId
        )
    );

    console.error(JSON.stringify(d, null, 4));

    const shstMatchedSegmentOffsetsByTargetMap = getShstMatchedSegmentOffsetsByTargetMap(
      {
        shstReferenceFeature,
        shstReferenceAuxProperties,
        shstMatchesByTargetMap
      }
    );

    const shstReferencePartitions = partitionShstReferenceByTargetMapsMatches({
      shstReferenceFeature,
      shstReferenceAuxProperties,
      shstMatchedSegmentOffsetsByTargetMap
    });

    if (shstReferencePartitions) {
      batch.push(...shstReferencePartitions.filter(p => p));
    } else {
      console.error(`NO MAPPINGS FOR SHST_REF_ID=${id}`);
    }

    if (batch.length >= BATCH_SIZE) {
      // await conflationMapService.putFeatures(batch);
      console.log('BATCH WRITE OF', BATCH_SIZE);
      batch.length = 0;
    }
  }
  console.log('DONE');
  // await conflationMapService.putFeatures(batch);
})();
