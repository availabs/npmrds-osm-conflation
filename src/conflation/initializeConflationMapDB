#!/usr/bin/env node

/* eslint no-continue: 0, no-param-reassign: 0, no-underscore-dangle: 0 */

const { readFileSync } = require('fs');
const { join } = require('path');
const { pipe, through } = require('mississippi');
const { sync: rimrafSync } = require('rimraf');
const _ = require('lodash');
const turf = require('@turf/turf');

const levelup = require('levelup');
const leveldown = require('leveldown');
const encode = require('encoding-down');

const SHST_GEOGRAPHY_DB = join(__dirname, '../../data/leveldb/shstGeometry/');
const SHST_METADATA_DB = join(__dirname, '../../data/leveldb/shstMetadata/');

const CONFLATION_MAP_DB = join(__dirname, '../../data/leveldb/conflationMap/');

rimrafSync(CONFLATION_MAP_DB);

const shstGeometryDB = levelup(
  encode(leveldown(SHST_GEOGRAPHY_DB), { valueEncoding: 'json' })
);

const shstMetadataDB = levelup(
  encode(leveldown(SHST_METADATA_DB), { valueEncoding: 'json' })
);

const conflationMapDB = levelup(
  encode(leveldown(CONFLATION_MAP_DB), { valueEncoding: 'json' })
);

const nysBoundingPolygon = JSON.parse(
  readFileSync(join(__dirname, '../../data/tiger/nys.bounding.geojson'))
);

// https://github.com/sharedstreets/sharedstreets-types/blob/3c1d5822ff4943ae063f920e018dd3e349213c8c/index.ts#L33-L44
const shstOsmWayRoadClass = {
  Motorway: 0,
  Trunk: 1,
  Primary: 2,
  Secondary: 3,
  Tertiary: 4,
  Residential: 5,
  Unclassified: 6,
  Service: 7,
  Other: 8
};

pipe(
  shstGeometryDB.createValueStream(),
  through.obj(async function splitter(feature, $, cb) {
    // Because the SharedStreets tiles include all roads near the NYS Border, including other states' roads.
    const withinNYS =
      nysBoundingPolygon.geometry.type === 'MultiPolygon'
        ? nysBoundingPolygon.geometry.coordinates.some(coordinates =>
            turf.booleanWithin(feature, { type: 'Polygon', coordinates })
          )
        : turf.booleanWithin(feature, nysBoundingPolygon);

    const nysRoad =
      withinNYS ||
      !!turf.lineIntersect(feature, nysBoundingPolygon).features.length;

    const {
      properties: {
        id: geometryId,
        fromIntersectionId,
        toIntersectionId,
        forwardReferenceId,
        backReferenceId
      },
      geometry
    } = feature;

    let osmMetadata = null;

    try {
      ({ osmMetadata } = await shstMetadataDB.get(geometryId));
    } catch (err) {
      console.error(err);
      console.warn('WARNING: No metadata found from shstGeometry', geometryId);
    }

    if (osmMetadata && Array.isArray(osmMetadata.waySections)) {
      const { waySections } = osmMetadata;

      for (let i = 0; i < waySections.length; ++i) {
        const waySection = waySections[i];
        const { roadClass } = waySection;
        waySection.fsystem = Number.isFinite(shstOsmWayRoadClass[roadClass])
          ? shstOsmWayRoadClass[roadClass]
          : shstOsmWayRoadClass.Other;
      }
    }

    if (
      osmMetadata &&
      osmMetadata.oneWay &&
      forwardReferenceId &&
      backReferenceId
    ) {
      console.warn(
        'WARNING: one-way OSM way with two sharedstreets references.'
      );
    }

    if (forwardReferenceId) {
      const properties = {
        geometryId,
        referenceId: forwardReferenceId,
        fromIntersectionId,
        toIntersectionId,
        reversed: false,
        state: nysRoad ? 'ny' : null,
        osmMetadata
      };

      this.push(Object.assign({}, feature, { properties }));
    }

    if (backReferenceId) {
      const reversedOsmMetadata = _.cloneDeep(osmMetadata);

      if (reversedOsmMetadata) {
        reversedOsmMetadata.waySections.reverse();
        reversedOsmMetadata.waySections.forEach(waySection =>
          waySection.nodeIds.reverse()
        );
        reversedOsmMetadata._reversed = true;
      }

      const properties = {
        geometryId,
        referenceId: backReferenceId,
        fromIntersectionId: toIntersectionId,
        toIntersectionId: fromIntersectionId,
        reversed: true,
        state: nysRoad ? 'ny' : null,
        osmMetadata: reversedOsmMetadata
      };

      const reversedCoords = geometry.coordinates.slice().reverse();

      this.push(
        Object.assign({}, feature, {
          properties,
          geometry: { type: 'LineString', coordinates: reversedCoords }
        })
      );
    }
    return cb();
  }),
  through.obj(async function loader(feature, $, cb) {
    try {
      const {
        properties: {
          referenceId,
          fromIntersectionId,
          toIntersectionId,
          reversed
        },
        geometry: { coordinates }
      } = feature;

      let preferedFeature = feature;

      try {
        const other = await conflationMapDB.get(referenceId);
        // Prefer original geometries to ones we created by reversing
        if (reversed !== other.properties.reversed) {
          preferedFeature = reversed ? other : feature;
        } else if (
          // The terminal intersections are the same
          other.properties.fromIntersectionId === fromIntersectionId &&
          other.properties.toIntersectionId === toIntersectionId
        ) {
          // choose the geometry with the higher resolution
          if (coordinates.length < other.geometry.coordinates.length) {
            preferedFeature = other;
          }
        } else {
          // Cannot pick, so throw
          const a = JSON.stringify(feature, null, 4);
          const b = JSON.stringify(other, null, 4);
          const msg = `INVARIANT BROKEN: reference refers to different road segments\n${a}\n${b}`;
          throw new Error(msg);
        }
      } catch (err) {
        if (err.type !== 'NotFoundError') {
          throw new Error(err);
        }
      }

      await conflationMapDB.put(referenceId, preferedFeature);

      return cb();
    } catch (err) {
      console.error(err);
      throw err;
    }
  }),
  err => {
    if (err) {
      console.error(
        'ERROR encountered while loading targetMapsSegmentOffsets DB.'
      );
      console.error(
        `    Deleting the corruped database at ${CONFLATION_MAP_DB}`
      );
      console.error();
      console.error(err);
      rimrafSync(CONFLATION_MAP_DB);
      process.exit(1);
    }
  }
);
