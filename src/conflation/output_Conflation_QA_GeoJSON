#!/usr/bin/env node

/* eslint no-param-reassign: 0 */

const { join } = require('path');
const { pipe, through } = require('mississippi');
const _ = require('lodash');

const levelup = require('levelup');
const leveldown = require('leveldown');
const encode = require('encoding-down');

const CONFLATION_MAP_DB = join(
  __dirname,
  '../../data/leveldb/',
  'conflationMap/'
);

const CONFLATION_PAIRINGS_DB = join(
  __dirname,
  '../../data/leveldb/',
  'conflationPairingsDB'
);

const conflationMapDB = levelup(
  encode(leveldown(CONFLATION_MAP_DB), { valueEncoding: 'json' })
);

const conflationPairingsDB = levelup(
  encode(leveldown(CONFLATION_PAIRINGS_DB), {
    valueEncoding: 'json'
  })
);

const geoJSONOpen =
  '{"type":"FeatureCollection","name":"networkconflation","crs":{"type":"name","properties":{"name":"urn:ogc:def:crs:OGC:1.3:CRS84"}},"features":[';

const geoJSONClose = ']}';

let preDelim = '';

const pairedReferenceGeoms = new Set();

const outputPairedShStGeoms = () =>
  new Promise((resolve, reject) =>
    pipe(
      conflationPairingsDB.createReadStream(),
      through.obj(async function writer(
        { key: geomId, value: feature },
        $,
        cb
      ) {
        const properties = {
          id: geomId,
          osm: _.get(feature.properties, 'OSM', null),
          npmrds: _.get(feature.properties, 'NPMRDS', null),
          ris: _.get(feature.properties, 'RIS', null)
        };

        pairedReferenceGeoms.add(geomId.replace(/\..*/, ''));

        const outFeature = Object.assign(feature, { properties });
        process.stdout.write(`${preDelim}${JSON.stringify(outFeature)}`);
        preDelim = ',';

        return cb();
      }),
      err => {
        if (err) {
          return reject(err);
        }
        return resolve();
      }
    )
  );

const outputUnpairedShStGeoms = () =>
  new Promise((resolve, reject) =>
    pipe(
      conflationMapDB.createReadStream(),
      through.obj(async function writer(
        { key: geomId, value: feature },
        $,
        cb
      ) {
        // if (!pairedReferenceGeoms.has(geomId)) {
        // pairedReferenceGeoms.add(geomId);
        // feature.properties.paired = false;
        // process.stdout.write(`${preDelim}${JSON.stringify(feature)}`);
        // preDelim = ',';
        // }

        if (feature.properties.state && !pairedReferenceGeoms.has(geomId)) {
          console.warn(
            'WARNING: shstRef',
            geomId,
            'was not paired to any target map segments'
          );
        }

        return cb();
      }),
      err => {
        if (err) {
          return reject(err);
        }
        return resolve();
      }
    )
  );

(async () => {
  try {
    process.stdout.write(geoJSONOpen);
    await outputPairedShStGeoms();
    await outputUnpairedShStGeoms();
    console.log(geoJSONClose);
  } catch (err) {
    console.error(err);
    process.exit(1);
  }
})();
