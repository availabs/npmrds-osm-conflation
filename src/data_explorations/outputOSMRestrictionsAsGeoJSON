#!/usr/bin/env node

const { join } = require('path');
const { pipe, through } = require('mississippi');

const levelup = require('levelup');
const leveldown = require('leveldown');
const encode = require('encoding-down');

const _ = require('lodash');
const turfHelpers = require('@turf/helpers');

const NODES_DIR = join(__dirname, '../../data/leveldb/', 'osmNodes');
const RESTRICTIONS_DIR = join(
  __dirname,
  '../../data/leveldb/',
  'osmRestrictions'
);

const nodesDb = levelup(
  encode(leveldown(NODES_DIR), { valueEncoding: 'json' })
);

const restrictionsDb = levelup(
  encode(leveldown(RESTRICTIONS_DIR), { valueEncoding: 'json' })
);

const geoJSONOpen =
  '{"type":"FeatureCollection","name":"networkconflation","crs":{"type":"name","properties":{"name":"urn:ogc:def:crs:OGC:1.3:CRS84"}},"features":[';

const geoJSONClose = ']}';

let preDelim = '';

const outputRestrictions = () =>
  new Promise((resolve, reject) =>
    pipe(
      restrictionsDb.createReadStream(),
      through.obj(
        async function writer({ key: nodeId, value: restrictions }, $, cb) {
          if (!Array.isArray(restrictions)) {
            return cb();
          }

          let nodeMetadata;
          try {
            nodeMetadata = await nodesDb.get(nodeId);
          } catch (err) {
            console.warn(
              'WARNING: No OSM Node data for Restriction "via" node',
              nodeId
            );
            return cb();
          }

          const { lat, lon } = nodeMetadata;

          const point = turfHelpers.point([+lon, +lat]);

          for (let i = 0; i < restrictions.length; ++i) {
            const restriction = restrictions[i];
            const {
              $: { v: turnRestriction }
            } = restriction.tag.find(({ $: { k } }) => k.match(/restriction/i));
            const members = restriction.member.reduce(
              (acc, { $: { role, ref } }) => {
                acc[role] = ref;
                return acc;
              },
              {}
            );

            const feature = _.cloneDeep(point);
            feature.properties = {
              nodeId,
              members,
              restriction: turnRestriction
            };

            this.push(`${preDelim}${JSON.stringify(feature)}`);
            preDelim = ',';
          }

          return cb();
        },
        function flush(cb) {
          this.push(geoJSONClose);
          return cb();
        }
      ),
      process.stdout,
      err => {
        if (err) {
          return reject(err);
        }
        return resolve();
      }
    )
  );

(async () => {
  process.stdout.write(geoJSONOpen);
  try {
    await outputRestrictions();
  } catch (err) {
    console.error(err);
  }
})();
