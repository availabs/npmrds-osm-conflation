#!/usr/bin/env node

// Takes a NDJSON file of GeoJSON feaures via STDIN
//   And outputs to STDOUT a valid GeoJSON object

const yargs = require('yargs');
const { through } = require('mississippi');
const split = require('split2');
const turf = require('@turf/turf');
const {
  flattenDeep,
  flattenDepth,
  first,
  last,
  isEqual,
  intersection,
  sum,
  map,
  flatten,
  union
} = require('lodash');
const { Graph, alg } = require('graphlib');

const EnhancedIndexedNDJSONFile = require('../lib/EnhancedIndexedNDJSONFile');

const { argv } = yargs
  .strict()
  .parserConfiguration({
    'camel-case-expansion': false,
    'flatten-duplicate-arrays': false
  })
  .wrap(yargs.terminalWidth() / 1.618)
  .option({
    inrixMetadataFile: {
      demand: true,
      type: 'string'
    },
    osmMetadataFile: {
      demand: true,
      type: 'string'
    }
  });

const { inrixMetadataFile, osmMetadataFile } = argv;

console.error('Indexing the inrixMetadataFile');
const inrixMetadata = new EnhancedIndexedNDJSONFile({
  filePath: inrixMetadataFile,
  key: 'properties.Tmc'
});
console.error('inrixMetadataFile indexing done');

console.error('Indexing the osmMetadataFile');
const osmMetadata = new EnhancedIndexedNDJSONFile({
  filePath: osmMetadataFile,
  key: 'properties.id'
});
console.error('osmMetadataFile indexing done');

const getWayFeatureChains = wayFeatures => {
  const wayFeaturesById = wayFeatures.reduce((acc, feature) => {
    if (!feature) {
      return null;
    }

    const {
      properties: { id }
    } = feature;

    acc[id] = feature;

    return acc;
  }, {});

  const subnet = new Graph({ directed: false, multigraph: true });

  for (let i = 0; i < wayFeatures.length; ++i) {
    const wayFeature = wayFeatures[i];

    if (!wayFeature) {
      continue;
    }

    const {
      properties: { id, nodes }
    } = wayFeature;

    const n0 = first(nodes);
    const nM = last(nodes);

    subnet.setEdge(n0, nM, id);
  }

  const wayChains = alg.components(subnet).map(component => {
    const [source] = intersection(
      union(subnet.sinks(), subnet.sources()),
      component
    );

    const preorderTraversalNodes = alg.preorder(
      subnet,
      source || first(component)
    );

    const [n0, n1] = preorderTraversalNodes;
    const firstWay = wayFeaturesById[subnet.edge(n0, n1)];

    if (firstWay && firstWay.properties.nodes[0] === n1) {
      preorderTraversalNodes.reverse();
    }

    const wayIds = preorderTraversalNodes.reduce((acc, node, i, traversal) => {
      if (i) {
        const wayId = subnet.edge(traversal[i - 1], node);
        if (wayId) {
          acc.push(wayFeaturesById[wayId]);
        }
      }

      return acc;
    }, []);

    return wayIds;
  });

  return wayChains;
};

const createWayChainsMultiLine = ({ tmc, wayFeatureChains }) => {
  const tmcMetadata = inrixMetadata.get(tmc);
  const {
    properties: { miles: tmc_shp_miles = null }
  } = tmcMetadata;

  const tmc_turf_miles = turf.length(tmcMetadata, { units: 'miles' });

  const ways = wayFeatureChains.map(chain => map(chain, 'properties.id'));

  const combinedLength = sum(
    flattenDeep(wayFeatureChains).map(way =>
      turf.length(way, { units: 'miles' })
    )
  );

  const combinedNodes = wayFeatureChains.map(chain =>
    map(chain, 'properties.nodes').reduce((acc, node, i, nodes) => {
      const prevNode = nodes[i - 1];

      if (node !== prevNode) {
        acc.push(node);
      }

      return acc;
    }, [])
  );

  const combinedCoordinates = wayFeatureChains.map(chain =>
    flatten(map(chain, 'geometry.coordinates')).reduce(
      (acc, coords, i, coordsArr) => {
        const prevCoords = coordsArr[i - 1];

        if (!isEqual(coords, prevCoords)) {
          acc.push(coords);
        }

        return acc;
      },
      []
    )
  );

  // TODO: Properties are the same for all ways can be added to the combined geojson
  const chainGeoJSON = turf.multiLineString(combinedCoordinates, {
    tmc,
    tmc_shp_miles,
    tmc_turf_miles,
    ways,
    ways_turf_miles: combinedLength,
    nodes: combinedNodes
  });

  return chainGeoJSON;
};

process.stdin
  .pipe(split(JSON.parse))
  .pipe(
    through.obj(function createWayChains({ tmc, ways }, _, cb) {
      console.error(tmc);
      const wayFeatures = ways.map(way => osmMetadata.get(way));
      const wayFeatureChains = getWayFeatureChains(wayFeatures);

      const wayChainsMultiLine = createWayChainsMultiLine({
        tmc,
        wayFeatureChains
      });

      this.push(`${JSON.stringify(wayChainsMultiLine)}\n`);
      return cb();
    })
  )
  .pipe(process.stdout);
