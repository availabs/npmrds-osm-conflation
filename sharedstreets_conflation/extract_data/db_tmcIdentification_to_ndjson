#!/usr/bin/env node

/* eslint no-plusplus: 0, no-await-in-loop: 0, no-constant-condition: 0 */

const Cursor = require('pg-cursor');

const TMCS_CHUNK_SIZE = 1000;

const { pool, query, end } = require('../../src/services/db_service');

const getTmcIdentificationTables = async () => {
  const sql = `
    SELECT DISTINCT
        'public.' || tablename AS table
      FROM pg_catalog.pg_tables
      WHERE (
        ( schemaname = 'public' )
        AND
        ( tablename LIKE 'tmc_identification%' )
      )
    ;
  `;

  const { rows } = await query(sql);

  return rows.map(({ table }) => table).filter(table => table);
};

// ??? Was the different highway types filter intended ???
const getTmcMetadataDBCursor = (client, tmcIdentificationTables) => {
  const subQuery = tmcIdentificationTables.map(
    table => `
        SELECT
            tmc,
            type,
            road,
            road_order,
            intersection,
            tmclinear,
            country,
            state,
            county,
            zip,
            direction,
            start_latitude,
            start_longitude,
            end_latitude,
            end_longitude,
            miles,
            frc,
            border_set,
            isprimary,
            f_system,
            urban_code,
            faciltype,
            structype,
            thrulanes,
            route_numb,
            route_sign,
            route_qual,
            altrtename,
            active_end_date
          FROM ${table}`
  ).join(`
        UNION ALL`);

  const sql = `
    SELECT DISTINCT ON (tmc)
        *
      FROM (${subQuery}) AS t
      ORDER BY tmc, active_end_date DESC
  `;

  return client.query(new Cursor(sql));
};

(async () => {
  try {
    const client = await pool.connect();

    const tmcIdentificationTables = await getTmcIdentificationTables();

    const tmcMetadataCursor = getTmcMetadataDBCursor(
      client,
      tmcIdentificationTables
    );

    const fn = (resolve, reject) => {
      tmcMetadataCursor.read(TMCS_CHUNK_SIZE, (err, rows) => {
        if (err) {
          return reject(err);
        }

        return resolve(rows);
      });
    };

    while (true) {
      const rows = await new Promise(fn);

      if (!rows.length) {
        client.release();
        break;
      }

      for (let i = 0; i < rows.length; ++i) {
        console.log(JSON.stringify(rows[i]));
      }
    }

    end();
  } catch (err) {
    console.error(err);
    process.exit(1);
  }
})();
