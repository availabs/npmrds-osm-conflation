#!/usr/bin/env node

// https://github.com/sharedstreets/sharedstreets-ref-system#core-concepts

const { spawn } = require('child_process');
const { pipe } = require('mississippi');
const split = require('split2');
const csv = require('fast-csv');
const { Throttle } = require('stream-throttle');

const { from: copyFrom } = require('pg-copy-streams');

const yargs = require('yargs');
const { query, pool, end } = require('../src/services/db_service');

const NULL = 'NULL';

const { argv } = yargs
  .strict()
  .parserConfiguration({
    'camel-case-expansion': false,
    'flatten-duplicate-arrays': false
  })
  .wrap(yargs.terminalWidth() / 1.618)
  .option({
    shstTmcMatchesFile: {
      demand: true,
      type: 'string'
    },
    clean: {
      type: 'boolean',
      description: 'Truncate table before loading',
      default: false
    }
  });

const { shstTmcMatchesFile, clean } = argv;

const loadTmcShStMatches = () =>
  new Promise((resolve, reject) => {
    pool.connect((err, client, done) => {
      if (err) {
        return reject(err);
      }

      const headers = [
        'tmc',
        'shst_reference_id',
        'shst_geometry_id',
        'shst_from_intersection_id',
        'shst_to_intersection_id',
        'gis_reference_id',
        'gis_geometry_id',
        'gis_total_segments',
        'gis_segment_index',
        'gis_from_intersection_id',
        'gis_to_intersection_id',
        'start_side_of_street',
        'end_side_of_street',
        'side_of_street',
        'score',
        'match_type'
      ];

      const dbCopyStream = client.query(
        copyFrom(
          `COPY sharedstreets.tmc_matches(${headers}) FROM STDIN WITH NULL '${NULL}' CSV HEADER`
        )
      );

      const { stdout: tmcShStMatches } = spawn('jq', [
        '-c',
        '.features[].properties',
        `${shstTmcMatchesFile}`
      ]);

      return pipe(
        tmcShStMatches,
        new Throttle({ rate: 100000 }),
        split(JSON.parse),
        csv
          .format({
            headers
          })
          .transform(
            ({
              shstReferenceId,
              shstGeometryId,
              shstFromIntersectionId,
              shstToIntersectionId,
              gisReferenceId,
              gisGeometryId,
              gisTotalSegments,
              gisSegmentIndex,
              gisFromIntersectionId,
              gisToIntersectionId,
              startSideOfStreet,
              endSideOfStreet,
              sideOfStreet,
              score,
              matchType,
              pp_tmc
            }) => ({
              tmc: pp_tmc || NULL,
              shst_reference_id: shstReferenceId || NULL,
              shst_geometry_id: shstGeometryId || NULL,
              shst_from_intersection_id: shstFromIntersectionId || NULL,
              shst_to_intersection_id: shstToIntersectionId || NULL,
              gis_reference_id: gisReferenceId || NULL,
              gis_geometry_id: gisGeometryId || NULL,
              gis_total_segments: gisTotalSegments || NULL,
              gis_segment_index: gisSegmentIndex || NULL,
              gis_from_intersection_id: gisFromIntersectionId || NULL,
              gis_to_intersection_id: gisToIntersectionId || NULL,
              start_side_of_street: startSideOfStreet || NULL,
              end_side_of_street: endSideOfStreet || NULL,
              side_of_street: sideOfStreet || NULL,
              score: score || NULL,
              match_type: matchType || NULL
            })
          ),
        // process.stdout,
        dbCopyStream,
        copyErr => {
          if (copyErr) {
            return reject(copyErr);
          }
          done();
          return resolve();
        }
      );
    });
  });

(async () => {
  try {
    if (clean) {
      await query(`
        BEGIN;
        TRUNCATE sharedstreets.tmc_matches;
        COMMIT;
      `);
    }

    await loadTmcShStMatches();
    await end();
  } catch (err) {
    console.error(err);
    process.exit(1);
  }
})();
