#!/usr/bin/env node

/* Loads the NDJSON versions of the SharedStreets tileset into LevelDB databases */

/* eslint no-use-before-define: 0 */

const { spawn } = require('child_process');
const { join } = require('path');
const { pipe, through } = require('mississippi');
const split = require('split2');
const { chunk, uniqWith, isEqual } = require('lodash');
const { sync: rimrafSync } = require('rimraf');
const { sync: mkdirpSync } = require('mkdirp');
const { lineString } = require('@turf/helpers');

const levelup = require('levelup');
const leveldown = require('leveldown');
const encode = require('encoding-down');


const LEVELDB_DIR = join(__dirname, '../../data/sharedstreets/shst_tiles_leveldb')

mkdirpSync(LEVELDB_DIR)

const INTERSECTION_DB_DIR = join(LEVELDB_DIR, 'shstIntersectionsDB');
const METADATA_DB_DIR = join(LEVELDB_DIR, 'shstMetadataDB');
const GEOGRAPHY_DB_DIR = join(LEVELDB_DIR, 'shstGeographyDB');
const REFERENCE_DB_DIR = join(LEVELDB_DIR, 'shstReferenceDB');

rimrafSync(INTERSECTION_DB_DIR);
rimrafSync(METADATA_DB_DIR);
rimrafSync(GEOGRAPHY_DB_DIR);
rimrafSync(REFERENCE_DB_DIR);

const yargs = require('yargs');

const cliArgsSpec = {
  tilesetNDJSONDir: {
    demand: true,
    type: 'string'
  }
};

const { argv } = yargs
  .strict()
  .parserConfiguration({
    'camel-case-expansion': false,
    'flatten-duplicate-arrays': false
  })
  .example(
    './load_tileset_ndjson_into_db --tilesetNDJSONDir ./sharedstreets_ndjson --clean'
  )
  .wrap(yargs.terminalWidth() / 1.618)
  .option(cliArgsSpec);

const { tilesetNDJSONDir } = argv;

const TILESET_DIR = `${join(process.cwd(), tilesetNDJSONDir)}/`;

(async () => {
  try {
    await Promise.all([
      loadIntersections(),
      loadMetadata(),
      loadGeometries(),
      loadReferences()
    ]);
  } catch (err) {
    // cleanup on failure
    rimrafSync(INTERSECTION_DB_DIR);
    rimrafSync(METADATA_DB_DIR);
    rimrafSync(GEOGRAPHY_DB_DIR);
    rimrafSync(REFERENCE_DB_DIR);

    console.error(err);
  }
})();

async function loadIntersections() {
  return new Promise((resolve, reject) => {
    const db = levelup(
      encode(leveldown(INTERSECTION_DB_DIR), { valueEncoding: 'json' })
    );

    const { stdout: intersectionStream } = spawn(
      'cat',
      [`${TILESET_DIR}*.intersection.*.ndjson`, "| sed '/^$/d' | sort -u"],
      { shell: true }
    );

    const seenIds = new Set();

    return pipe(
      intersectionStream,
      split(JSON.parse),
      through.obj(async function loader(d, _, cb) {
        const { id } = d;

        if (seenIds.has(id)) {
          throw new Error('ERROR: Duplicate intersection id');
        }

        seenIds.add(id);

        await db.put(id, d);

        return cb();
      }),
      async err => {
        await db.close();

        if (err) {
          return reject(err);
        }

        return resolve();
      }
    );
  });
}

async function loadMetadata() {
  return new Promise((resolve, reject) => {
    const db = levelup(
      encode(leveldown(METADATA_DB_DIR), { valueEncoding: 'json' })
    );

    const { stdout: metadataStream } = spawn(
      'cat',
      [`${TILESET_DIR}*.metadata.*.ndjson`, "| sed '/^$/d' | sort -u"],
      { shell: true }
    );

    const seenIds = new Set();

    return pipe(
      metadataStream,
      split(JSON.parse),
      through.obj(async function loader(d, _, cb) {
        const { geometryId: id } = d;

        if (seenIds.has(id)) {
          throw new Error('ERROR: Duplicate metadata geometryId');
        }

        seenIds.add(id);

        await db.put(id, d);

        return cb();
      }),
      async err => {
        if (err) {
          return reject(err);
        }

        await db.close();

        return resolve();
      }
    );
  });
}

/*
{
  "lonlats": [
    -79.739039,
    42.2649392,
    -79.73931680000001,
    42.2651741
  ],
  "id": "818d199c6aa1ea9472a351c49a4ea942",
  "fromIntersectionId": "36f36402e8bfd8681ed92c2f13a7660d",
  "toIntersectionId": "988be16c2c31be55830a84e138bd62e2",
  "forwardReferenceId": "8f510cc2997e944b068a2799ec638151",
  "backReferenceId": "f39aa235a203340e0e523f118c5201e5",
  "roadClass": "Service"
}
 */
async function loadGeometries() {
  return new Promise((resolve, reject) => {
    const db = levelup(
      encode(leveldown(GEOGRAPHY_DB_DIR), { valueEncoding: 'json' })
    );

    const { stdout: geometryStream } = spawn(
      'cat',
      [`${TILESET_DIR}*.geometry.*.ndjson`, "| sed '/^$/d' | sort -u"],
      { shell: true }
    );

    const seenIds = new Set();

    return pipe(
      geometryStream,
      split(JSON.parse),
      through.obj(async function loader(d, _, cb) {
        const {
          id,
          lonlats,
          fromIntersectionId,
          toIntersectionId,
          forwardReferenceId,
          backReferenceId,
          roadClass
        } = d;

        if (seenIds.has(id)) {
          throw new Error('ERROR: Duplicate geometry id');
        }

        const coords = chunk(lonlats, 2);

        const geojson = lineString(coords, {
          id,
          fromIntersectionId,
          toIntersectionId,
          forwardReferenceId,
          backReferenceId,
          roadClass
        });

        await db.put(id, geojson);

        return cb();
      }),
      async err => {
        if (err) {
          return reject(err);
        }

        await db.close();

        return resolve();
      }
    );
  });
}

async function loadReferences() {
  return new Promise((resolve, reject) => {
    const db = levelup(
      encode(leveldown(REFERENCE_DB_DIR), { valueEncoding: 'json' })
    );

    const { stdout: referenceStream } = spawn(
      'cat',
      [`${TILESET_DIR}*.reference.*.ndjson`, "| sed '/^$/d' | sort -u"],
      { shell: true }
    );

    return pipe(
      referenceStream,
      split(JSON.parse),
      through.obj(async function loader(d, _, cb) {
        const { id } = d;

        let list;

        try {
          list = await db.get(id);
        } catch (err) {
          if (err.type === 'NotFoundError') {
            list = [];
          } else {
            throw new Error(err);
          }
        }

        list.push(d);

        await db.put(id, uniqWith(list, isEqual));

        return cb();
      }),
      async err => {
        if (err) {
          return reject(err);
        }

        await db.close();

        return resolve();
      }
    );
  });
}
