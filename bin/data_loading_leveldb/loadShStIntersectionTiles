#!/usr/bin/env node

/*
SEE: https://github.com/sharedstreets/sharedstreets-ref-system#core-concepts

{
  "inboundReferenceIds": [
    "16efb4cc5d6a6388bb194406d456c31d",
    "fc59734dc6988995ab3832cbf01138df",
    "9b4cc0d2a6a638b72c712a37afde8c13"
  ],
  "outboundReferenceIds": [
    "6ef3502d937a1a5c9ffddc5ca638b3b9",
    "f9101168d69c6234aaf8239503cd1fb3",
    "c0d660b52f05d51cc14a45631db2581f"
  ],
  "id": "80107464c868bcd9a9c8b7056814e7a0",
  "nodeId": "5222590923",
  "lon": -79.78760390000001,
  "lat": 42.2306393
}
*/


const { readdirSync, readFileSync } = require('fs');
const { join } = require('path');
const { pipe, from, through } = require('mississippi');
const { uniqWith, isEqual } = require('lodash');
const { sync: rimrafSync } = require('rimraf');
const { sync: mkdirpSync } = require('mkdirp');

const levelup = require('levelup');
const leveldown = require('leveldown');
const encode = require('encoding-down');

const sharedstreetsPbf = require('sharedstreets-pbf');

const yargs = require('yargs');

const cliArgsSpec = {
  tilesetDir: {
    demand: true,
    type: 'string'
  },
  leveldbDir: {
    demand: true,
    type: 'string'
  },
  clean: {
    type: 'boolean',
    description: 'Empty the leveldbDir before beginning.',
    default: false
  }
};

const { argv } = yargs
  .strict()
  .parserConfiguration({
    'camel-case-expansion': false,
    'flatten-duplicate-arrays': false
  })
  .wrap(yargs.terminalWidth() / 1.618)
  .option(cliArgsSpec);

const { tilesetDir, leveldbDir, clean } = argv;

if (clean) {
  rimrafSync(leveldbDir);
}

mkdirpSync(leveldbDir);

const db = levelup(encode(leveldown(leveldbDir), { valueEncoding: 'json' }));

// NOTE: IIFE (Immediately Invoked Function Expression)
const intxnGenerator = (function* generator() {
  const tileFiles = readdirSync(tilesetDir).filter(f =>
    f.match(/intersection\.\d+\.pbf$/)
  );

  for (let i = 0; i < tileFiles.length; ++i) {
    const inf = tileFiles[i];

    try {
      const parser = sharedstreetsPbf.intersection;

      const d = parser(readFileSync(join(tilesetDir, inf)));

      for (let j = 0; j < d.length; ++j) {
        yield d[j];
      }
    } catch (err) {
      console.error(`WARNING: Error processing ${inf}`);
    }
  }
})();

pipe(
  from.obj(function intxnReadStream(size, next) {
    const { value: intxnMeta, done } = intxnGenerator.next();
    if (!intxnMeta && done) {
      return next(null, null);
    }

    return next(null, intxnMeta);
  }),
  through.obj(async function loader(d, _, cb) {
    const { id } = d;

    let list;

    try {
      list = await db.get(id);
    } catch (err) {
      if (err.type === 'NotFoundError') {
        list = [];
      } else {
        throw new Error(err);
      }
    }

    list.push(d);

    await db.put(id, uniqWith(list, isEqual));

    return cb();
  }),
  err => {
    if (err) {
      throw err;
    }

    db.close();
  }
);
