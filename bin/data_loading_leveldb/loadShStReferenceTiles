#!/usr/bin/env node

// https://github.com/sharedstreets/sharedstreets-ref-system#core-concepts

const { readdirSync, readFileSync } = require('fs');
const { join } = require('path');
const { pipe, from, through } = require('mississippi');
const { uniqWith, isEqual } = require('lodash');
const { sync: rimrafSync } = require('rimraf');
const { sync: mkdirpSync } = require('mkdirp');

const levelup = require('levelup');
const leveldown = require('leveldown');
const encode = require('encoding-down');

const sharedstreetsPbf = require('sharedstreets-pbf');

const yargs = require('yargs');

const cliArgsSpec = {
  tilesetDir: {
    demand: true,
    type: 'string'
  },
  leveldbDir: {
    demand: true,
    type: 'string'
  },
  clean: {
    type: 'boolean',
    description: 'Empty the leveldbDir before beginning.',
    default: false
  }
};

const { argv } = yargs
  .strict()
  .parserConfiguration({
    'camel-case-expansion': false,
    'flatten-duplicate-arrays': false
  })
  .wrap(yargs.terminalWidth() / 1.618)
  .option(cliArgsSpec);

const { tilesetDir, leveldbDir, clean } = argv;

if (clean) {
  rimrafSync(leveldbDir);
}

mkdirpSync(leveldbDir);

const db = levelup(encode(leveldown(leveldbDir), { valueEncoding: 'json' }));

const refsGenerator = (function* generator() {
  const tileFiles = readdirSync(tilesetDir).filter(f =>
    f.match(/reference\.\d+\.pbf$/)
  );

  for (let i = 0; i < tileFiles.length; ++i) {
    const inf = tileFiles[i];

    try {
      const parser = sharedstreetsPbf.reference;

      const d = parser(readFileSync(join(tilesetDir, inf)));

      for (let j = 0; j < d.length; ++j) {
        yield d[j];
      }
    } catch (err) {
      console.error(`WARNING: Error processing ${inf}`);
    }
  }
})();

pipe(
  from.obj(function refsReadStream(size, next) {
    const { value: geom, done } = refsGenerator.next();
    if (!geom && done) {
      return next(null, null);
    }

    return next(null, geom);
  }),
  through.obj(async function loader(d, _, cb) {
    const { id } = d;

    let list;

    try {
      list = await db.get(id);
    } catch (err) {
      if (err.type === 'NotFoundError') {
        list = [];
      } else {
        throw new Error(err);
      }
    }

    list.push(d);

    await db.put(id, uniqWith(list, isEqual));

    return cb();
  }),
  err => {
    if (err) {
      throw err;
    }

    db.close();
  }
);
