#!/usr/bin/env node

/* eslint no-use-before-define: 0 */

const { spawn } = require('child_process');
const { join } = require('path');
const { pipe, through } = require('mississippi');
const split = require('split2');
const { sync: rimrafSync } = require('rimraf');
const { sync: mkdirpSync } = require('mkdirp');

const levelup = require('levelup');
const leveldown = require('leveldown');
const encode = require('encoding-down');

const LEVELDB_DIR = join(__dirname, '../../data/npmrds/shst_matched_leveldb');

mkdirpSync(LEVELDB_DIR);

const SHST_MATCHED_NPMRDS_DB_DIR = join(LEVELDB_DIR, 'shstMatchedTMCs');

rimrafSync(SHST_MATCHED_NPMRDS_DB_DIR);

const yargs = require('yargs');

const cliArgsSpec = {
  shstMatchedDir: {
    demand: true,
    type: 'string'
  }
};

const { argv } = yargs
  .strict()
  .parserConfiguration({
    'camel-case-expansion': false,
    'flatten-duplicate-arrays': false
  })
  .example('./loadSharedStreetsMatchedNPMRDS --shstMatchedDir ./shst_matched ')
  .wrap(yargs.terminalWidth() / 1.618)
  .option(cliArgsSpec);

const { shstMatchedDir } = argv;

const DATA_DIR = `${join(process.cwd(), shstMatchedDir)}/`;

(async () => {
  try {
    await loadMatched();
  } catch (err) {
    // cleanup on failure
    rimrafSync(SHST_MATCHED_NPMRDS_DB_DIR);

    console.error(err);
  }
})();

async function loadMatched() {
  return new Promise((resolve, reject) => {
    const db = levelup(
      encode(leveldown(SHST_MATCHED_NPMRDS_DB_DIR), { valueEncoding: 'json' })
    );

    const { stdout: intersectionStream } = spawn(
      "jq --compact-output '.features[]'",
      [`${DATA_DIR}*\\.matched.geojson`, '| sort -u'],
      { shell: true }
    );

    return pipe(
      intersectionStream,
      split(JSON.parse),
      through.obj(async function loader(d, _, cb) {
        const {
          properties: { pp_tmc: tmc }
        } = d;

        let list;

        try {
          list = await db.get(tmc);
        } catch (err) {
          if (err.type === 'NotFoundError') {
            list = [];
          } else {
            throw new Error(err);
          }
        }

        list.push(d);

        await db.put(tmc, list);

        return cb();
      }),
      async err => {
        await db.close();

        if (err) {
          return reject(err);
        }

        return resolve();
      }
    );
  });
}
