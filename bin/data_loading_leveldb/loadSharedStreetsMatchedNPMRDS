#!/usr/bin/env node

/* eslint no-use-before-define: 0 */

const { spawn } = require('child_process');
const { join } = require('path');
const { pipe, through } = require('mississippi');
const split = require('split2');
const { sync: rimrafSync } = require('rimraf');
const { sync: mkdirpSync } = require('mkdirp');

const levelup = require('levelup');
const leveldown = require('leveldown');
const encode = require('encoding-down');

const yargs = require('yargs');

const cliArgsSpec = {
  shstMatchedDir: {
    demand: true,
    type: 'string'
  },
  leveldbDir: {
    demand: true,
    type: 'string'
  },
  clean: {
    type: 'boolean',
    description: 'Empty the leveldbDir before beginning.',
    default: false
  }
};

const { argv } = yargs
  .strict()
  .parserConfiguration({
    'camel-case-expansion': false,
    'flatten-duplicate-arrays': false
  })
  .example('./loadSharedStreetsMatchedNPMRDS --shstMatchedDir ./shst_matched ')
  .wrap(yargs.terminalWidth() / 1.618)
  .option(cliArgsSpec);

const { shstMatchedDir, leveldbDir, clean } = argv;

const DATA_DIR = `${join(process.cwd(), shstMatchedDir)}/`;

if (clean) {
  rimrafSync(leveldbDir);
}

mkdirpSync(leveldbDir);

const db = levelup(encode(leveldown(leveldbDir), { valueEncoding: 'json' }));

const { stdout: matchedStream } = spawn(
  "jq --compact-output '.features[]'",
  [`${DATA_DIR}*\\.matched.geojson`, '| sort -u'],
  { shell: true }
);

pipe(
  matchedStream,
  split(JSON.parse),
  through.obj(async function loader(d, _, cb) {
    const {
      properties: { pp_tmc: tmc }
    } = d;

    let list;

    try {
      list = await db.get(tmc);
    } catch (err) {
      if (err.type === 'NotFoundError') {
        list = [];
      } else {
        throw new Error(err);
      }
    }

    list.push(d);

    await db.put(tmc, list);

    return cb();
  }),
  async err => {
    await db.close();

    if (err) {
      rimrafSync(leveldbDir);
    }
  }
);
