#!/usr/bin/env node

/* eslint no-param-reassign: 0 */

const { exec } = require('child_process');
const { openSync, appendFileSync, closeSync } = require('fs');
const { join } = require('path');
const split = require('split2');
const { pipe, through } = require('mississippi');
const yargs = require('yargs');
const { sync: mkdirpSync } = require('mkdirp');

const cliArgsSpec = {
  risGeodatabase: {
    demand: true,
    type: 'string',
    description:
      'Path to the RIS GeoDatabase. It is REQUIRED that every record has a populated County_Name field.'
  },
  outDir: {
    demand: true,
    type: 'string',
    description:
      'The directory into which to write the county geojson files. Creates directory if it does not exist.'
  }
};

const { argv } = yargs
  .strict()
  .parserConfiguration({
    'camel-case-expansion': false,
    'flatten-duplicate-arrays': false
  })
  .wrap(yargs.terminalWidth() / 1.618)
  .option(cliArgsSpec)
  .usage(
    `Creates County partitions of the RIS geodatabase.
    One GeoJSON file is created per county.
    GeoJSON files are written into the specified --outDir directory.
    SRS transformed to CRS84 (ESPG4326).

    USAGE:
      ogr2ogr -f GeoJSON /vsistdout/ -t_srs data/ris/RISDuplicate.gdb |
        jq -c '.features[]' |
        ./partitionRISGeodatabaseIntoCountyGeoJSONs --outDir foo
    `
  );

const { risGeodatabase, outDir } = argv;

mkdirpSync(outDir);

const cmd = `ogr2ogr -f GeoJSON /vsistdout/ ${risGeodatabase} -t_srs 'EPSG:4326' -dim 2 -preserve_fid | jq -c '.features[]'`;

console.error(cmd);

const { stdout: risFeatureStream } = exec(cmd, {
  //  maxBuffer
  //    Largest amount of data in bytes allowed on stdout or stderr.
  //    If exceeded, the child process is terminated and any output is truncated.
  //
  //  Better to crash hard on out of memory than to get cryptic "pipe closed prematurely" error.
  maxBuffer: Infinity
});

const countyPartitionFDs = {};

const geoJSONHeader =
  '{"type":"FeatureCollection","name":"roadwayinventory","crs":{"type":"name","properties":{"name":"urn:ogc:def:crs:OGC:1.3:CRS84"}},"features":[';

pipe(
  risFeatureStream,
  split(JSON.parse),
  through.obj(
    function countyPartitioner(feature, _, cb) {
      const {
        properties: { County_Name }
      } = feature;

      feature.properties.ogc_fid = feature.id;

      const d = JSON.stringify(feature);

      if (!County_Name) {
        throw new Error(
          'ERROR: Empty Column_Name field for RIS Geodatabase entry.'
        );
      }

      const normalizedCountyName = County_Name.toLowerCase().replace(/ /, '_');

      let fd = countyPartitionFDs[normalizedCountyName];
      if (!fd) {
        const outf = join(outDir, `ris.${normalizedCountyName}.geojson`);
        fd = openSync(outf, 'a');

        countyPartitionFDs[normalizedCountyName] = fd;

        appendFileSync(fd, `${geoJSONHeader}${d}`, 'utf8');
      } else {
        appendFileSync(fd, `,${d}`, 'utf8');
      }

      return cb();
    },
    function finish(cb) {
      Object.keys(countyPartitionFDs).forEach(county => {
        const fd = countyPartitionFDs[county];

        appendFileSync(fd, ']}');

        closeSync(fd);
      });

      console.error('done');
      return cb();
    }
  ),
  err => {
    if (err) {
      console.error(err);
    }
  }
);
