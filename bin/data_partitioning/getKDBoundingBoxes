#!/usr/bin/env node

// Takes a NDJSON file of GeoJSON feaures via STDIN
//   And outputs to STDOUT a valid GeoJSON object
/* eslint no-cond-assign: 0, no-use-before-define: 0 */

const { pipe } = require('mississippi');
const split = require('split2');
const { through } = require('mississippi');
const yargs = require('yargs');
const turf = require('@turf/turf');

const {
  isEqual,
  chunk,
  flattenDeep,
  uniq,
  uniqWith,
  findLast,
  head,
  tail
} = require('lodash');

const cliArgsSpec = {
  N: {
    demand: false,
    type: 'number',
    description: '(Roughly) Max number of features per bounding box.',
    default: 2 ** 14
  },
  SRID: {
    demand: false,
    type: 'string',
    description: "The input data's SRID",
    default: 'OGC:1.3:CRS84'
  },
  outputFormat: {
    demand: false,
    type: 'string',
    description: 'The output data format.',
    default: 'GeoJSON',
    options: ['GeoJSON', 'osmosis']
  }
};

const { argv } = yargs
  .strict()
  .parserConfiguration({
    'camel-case-expansion': false,
    'flatten-duplicate-arrays': false
  })
  .wrap(yargs.terminalWidth() / 1.618)
  .option(cliArgsSpec)
  .usage(
    `Consumes NDJSON file through STDIN and outputs to STDOUT the partitioning bounding boxes as GeoJSON.
    USAGE:
      ./getKDBoundingBoxes -N 1028 < foo.ndjson > bar.geojson
    `
  );

const { N, SRID, outputFormat } = argv;

const crs = {
  type: 'name',
  properties: {
    name: `urn:ogc:def:crs:${SRID}`
  }
};

const featureBoundingBoxes = {};
let id = 0;

pipe(
  process.stdin,
  split(JSON.parse),
  through.obj(
    function featureBBoxCollector(feature, _, cb) {
      featureBoundingBoxes[id++] = turf.bbox(feature);
      cb();
    },
    function flush(cb) {
      // ---------------------------------------------------------------------------
      const featureIds = Object.keys(featureBoundingBoxes);

      const minX = Math.min(...featureIds.map(i => featureBoundingBoxes[i][0]));
      const minY = Math.min(...featureIds.map(i => featureBoundingBoxes[i][1]));
      const maxX = Math.max(...featureIds.map(i => featureBoundingBoxes[i][2]));
      const maxY = Math.max(...featureIds.map(i => featureBoundingBoxes[i][3]));

      const partitions = partitionIds(featureIds);
      const boundingBoxes = createBoundingBoxes(
        [minX, minY, maxX, maxY],
        partitions
      );

      if (outputFormat === 'GeoJSON') {
        const bbPolygons = turf.featureCollection(
          Array.isArray(boundingBoxes[0])
            ? boundingBoxes.map(bb => turf.bboxPolygon(bb))
            : [turf.bboxPolygon(boundingBoxes)]
        );

        bbPolygons.crs = crs;

        const { features } = bbPolygons;
        for (let i = 0; i < features.length; ++i) {
          features[i].crs = crs;
        }

        this.push(JSON.stringify(bbPolygons));
      }

      // https://wiki.openstreetmap.org/wiki/Osmosis/Detailed_Usage_0.47#--bounding-box_.28--bb.29
      if (outputFormat === 'osmosis') {
        const osmosisBoundingBoxes = (Array.isArray(boundingBoxes[0])
          ? boundingBoxes
          : [boundingBoxes]
        ).map(
          ([left, bottom, right, top]) =>
            `left=${left} bottom=${bottom} right=${right} top=${top}`
        );

        this.push(`${osmosisBoundingBoxes.join('\n')}\n`);
      }

      return cb();
    }
  ),
  process.stdout
);

function partitionIds(ids, dimension = 0) {
  const len = ids.length;

  if (len <= N) {
    return null;
  }

  const nextDimension = (dimension + 1) % 2;

  const dimensionCoords = ids.map(i => featureBoundingBoxes[i][dimension]);

  // Only one common value amongst dimension coords.
  //   Can't partition any further.
  if (uniq(dimensionCoords).length === 1) {
    return null;
  }

  dimensionCoords.sort((a, b) => +a - +b);

  // Get the median coords for the partition coord.
  let partitionCoord = dimensionCoords[Math.floor(len / 2)];

  // If the partition coord is the max, we end up in an infinite recursion.
  //   Get the next largest coord for the partition coord.
  if (partitionCoord === Math.max(...dimensionCoords)) {
    partitionCoord = findLast(dimensionCoords, c => c < partitionCoord);
  }

  // Create two partitions of ids.
  const partitions = ids.reduce(
    (acc, i) => {
      const p = +(featureBoundingBoxes[i][dimension] > partitionCoord);
      acc[p].push(i);
      return acc;
    },
    [[], []]
  );

  // Recursively partition further.
  const p = [
    partitionIds(partitions[0], nextDimension),
    partitionIds(partitions[1], nextDimension)
  ];

  // If we were able to further split each child partition on
  //   the next dimension, return those partitions.
  //   Otherwise, we stop partitioning here.
  //   This is to simplify the createBoundingBoxes step.
  //   It is not logically necessary.
  //   TODO: support one-sided child partitioning.
  return p[0] && p[1] ? [partitionCoord, ...p] : partitionCoord;
}

function createBoundingBoxes(bb, partitions, dimension = 0) {
  // No further splitting.
  if (!partitions) {
    return bb;
  }

  // Do further recursive partitioning of the bbox.
  if (Array.isArray(head(partitions))) {
    return uniqWith(
      // Get rid of dupes. TODO: Why are there dupes?
      // Cunk them by groups of four (minX, minY, maxX, maxY)
      chunk(
        // Flatten out the coords.
        flattenDeep([
          createBoundingBoxes(bb, partitions[0], dimension),
          createBoundingBoxes(bb, partitions[1], dimension)
        ]),
        4
      ),
      isEqual
    );
  }

  // We are at the tail of a partitioning.

  const [minx, miny, maxx, maxy] = bb;
  const nextDimension = (dimension + 1) % 2;

  const partitionCoord = head(partitions);
  const restPartitionCoords = tail(partitions);

  let bbA;
  let bbB;

  // Split the bounding box along the partition coord
  if (dimension === 0) {
    bbA = partitionCoord ? [minx, miny, partitionCoord, maxy] : bb;
    bbB = partitionCoord ? [partitionCoord, miny, maxx, maxy] : bb;
  } else {
    bbA = partitionCoord ? [minx, miny, maxx, partitionCoord] : bb;
    bbB = partitionCoord ? [minx, partitionCoord, maxx, maxy] : bb;
  }

  return uniqWith(
    // Get rid of dupes. TODO: Why are there dupes?
    // Cunk them by groups of four (minX, minY, maxX, maxY)
    chunk(
      // Flatten out the coords.
      flattenDeep([
        createBoundingBoxes(bbA, restPartitionCoords[0], nextDimension),
        createBoundingBoxes(bbB, restPartitionCoords[1], nextDimension)
      ]),
      4
    ),
    isEqual
  );
}
